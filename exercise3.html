<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="chyx111@qq.com" />
  <title>算法分析习题选讲(第三章)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">MathJax.Hub.Queue(["Typeset",MathJax.Hub]);</script>
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">算法分析习题选讲(第三章)</h1>
  <p class="author">
chyx111@qq.com
  </p>
</div>
<div id="马周游" class="titleslide slide section level1"><h1>1152 1153 马周游</h1></div><div id="马周游-题目大意" class="slide section level2">
<h1>1152 1153 马周游 题目大意</h1>
<p>一个有限大小的棋盘上有一只马</p>
<p>给出初始时马的位置，找出一条马移动的路线，经过所有格子各一次</p>
<div id="knight">

</div>
<script src="raphael.js"></script>
<script src="d3.v3.min.js"></script>
<script src="lecture.js"></script>
<script>
var w = h = 500;
var svg = d3.select("div#knight").append("svg")
.attr("width", w).attr("height", h);
KnightBoard.createNew(svg, w, h);
</script>

</div><div id="马周游-题目大意-1" class="slide section level2">
<h1>1152 1153 马周游 题目大意</h1>
<table>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="left"><strong>4</strong></td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
<td align="center">8</td>
</tr>
<tr class="even">
<td align="left">9</td>
<td align="center">10</td>
<td align="center">11</td>
<td align="left">12</td>
<td align="center">13</td>
<td align="center">14</td>
<td align="center">15</td>
<td align="center">16</td>
</tr>
<tr class="odd">
<td align="left">17</td>
<td align="center">18</td>
<td align="center">19</td>
<td align="left">20</td>
<td align="center">21</td>
<td align="center">22</td>
<td align="center">23</td>
<td align="center">24</td>
</tr>
<tr class="even">
<td align="left">25</td>
<td align="center">26</td>
<td align="center">27</td>
<td align="left">28</td>
<td align="center">29</td>
<td align="center">30</td>
<td align="center">31</td>
<td align="center">32</td>
</tr>
<tr class="odd">
<td align="left">33</td>
<td align="center">34</td>
<td align="center">35</td>
<td align="left">36</td>
<td align="center">37</td>
<td align="center">38</td>
<td align="center">39</td>
<td align="center">40</td>
</tr>
<tr class="even">
<td align="left">41</td>
<td align="center">42</td>
<td align="center">43</td>
<td align="left">44</td>
<td align="center">45</td>
<td align="center">46</td>
<td align="center">47</td>
<td align="center">48</td>
</tr>
<tr class="odd">
<td align="left">49</td>
<td align="center">50</td>
<td align="center">51</td>
<td align="left">52</td>
<td align="center">53</td>
<td align="center">54</td>
<td align="center">55</td>
<td align="center">56</td>
</tr>
<tr class="even">
<td align="left">57</td>
<td align="center">58</td>
<td align="center">59</td>
<td align="left">60</td>
<td align="center">61</td>
<td align="center">62</td>
<td align="center">63</td>
<td align="center">64</td>
</tr>
</tbody>
</table>
</div><div id="马周游-题目大意-2" class="slide section level2">
<h1>1152 1153 马周游 题目大意</h1>
<table>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="left"><strong>4</strong></td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
<td align="center">8</td>
</tr>
<tr class="even">
<td align="left">9</td>
<td align="center">10</td>
<td align="center">11</td>
<td align="left">12</td>
<td align="center">13</td>
<td align="center">14</td>
<td align="center">15</td>
<td align="center">16</td>
</tr>
<tr class="odd">
<td align="left">17</td>
<td align="center">18</td>
<td align="center">19</td>
<td align="left">20</td>
<td align="center"><strong>21</strong></td>
<td align="center">22</td>
<td align="center">23</td>
<td align="center">24</td>
</tr>
<tr class="even">
<td align="left">25</td>
<td align="center">26</td>
<td align="center">27</td>
<td align="left">28</td>
<td align="center">29</td>
<td align="center">30</td>
<td align="center">31</td>
<td align="center">32</td>
</tr>
<tr class="odd">
<td align="left">33</td>
<td align="center">34</td>
<td align="center">35</td>
<td align="left">36</td>
<td align="center">37</td>
<td align="center">38</td>
<td align="center">39</td>
<td align="center">40</td>
</tr>
<tr class="even">
<td align="left">41</td>
<td align="center">42</td>
<td align="center">43</td>
<td align="left">44</td>
<td align="center">45</td>
<td align="center">46</td>
<td align="center">47</td>
<td align="center">48</td>
</tr>
<tr class="odd">
<td align="left">49</td>
<td align="center">50</td>
<td align="center">51</td>
<td align="left">52</td>
<td align="center">53</td>
<td align="center">54</td>
<td align="center">55</td>
<td align="center">56</td>
</tr>
<tr class="even">
<td align="left">57</td>
<td align="center">58</td>
<td align="center">59</td>
<td align="left">60</td>
<td align="center">61</td>
<td align="center">62</td>
<td align="center">63</td>
<td align="center">64</td>
</tr>
</tbody>
</table>
</div><div id="马周游-题目大意-3" class="slide section level2">
<h1>1152 1153 马周游 题目大意</h1>
<table>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="left"><strong>4</strong></td>
<td align="center">5</td>
<td align="left"><strong>6</strong></td>
<td align="center">7</td>
<td align="center">8</td>
</tr>
<tr class="even">
<td align="left">9</td>
<td align="center">10</td>
<td align="center">11</td>
<td align="left">12</td>
<td align="center">13</td>
<td align="left">14</td>
<td align="center">15</td>
<td align="center">16</td>
</tr>
<tr class="odd">
<td align="left">17</td>
<td align="center">18</td>
<td align="center">19</td>
<td align="left">20</td>
<td align="center"><strong>21</strong></td>
<td align="left">22</td>
<td align="center">23</td>
<td align="center">24</td>
</tr>
<tr class="even">
<td align="left">25</td>
<td align="center">26</td>
<td align="center">27</td>
<td align="left">28</td>
<td align="center">29</td>
<td align="left">30</td>
<td align="center">31</td>
<td align="center">32</td>
</tr>
<tr class="odd">
<td align="left">33</td>
<td align="center">34</td>
<td align="center">35</td>
<td align="left">36</td>
<td align="center">37</td>
<td align="left">38</td>
<td align="center">39</td>
<td align="center">40</td>
</tr>
<tr class="even">
<td align="left">41</td>
<td align="center">42</td>
<td align="center">43</td>
<td align="left">44</td>
<td align="center">45</td>
<td align="left">46</td>
<td align="center">47</td>
<td align="center">48</td>
</tr>
<tr class="odd">
<td align="left">49</td>
<td align="center">50</td>
<td align="center">51</td>
<td align="left">52</td>
<td align="center">53</td>
<td align="left">54</td>
<td align="center">55</td>
<td align="center">56</td>
</tr>
<tr class="even">
<td align="left">57</td>
<td align="center">58</td>
<td align="center">59</td>
<td align="left">60</td>
<td align="center">61</td>
<td align="left">62</td>
<td align="center">63</td>
<td align="center">64</td>
</tr>
</tbody>
</table>
</div><div id="马周游-解题思路" class="slide section level2">
<h1>1152 1153 马周游 解题思路</h1>
<ul class="incremental">
<li><p>深搜</p></li>
<li><p>枚举马能走的所有路径，直至找到一条完成周游的路径</p></li>
<li><p>回溯</p></li>
</ul>
</div><div id="马周游-代码" class="slide section level2">
<h1>1152 1153 马周游 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> Solve(<span class="dt">int</span> x, <span class="dt">int</span> depth) {
  route[depth] = x + <span class="dv">1</span>;
  <span class="kw">if</span> (depth == m * n - <span class="dv">1</span>) {
    print_route();
    <span class="kw">return</span> <span class="kw">true</span>;
  }
  visit[x] = <span class="kw">true</span>;

  <span class="co">//搜索对效率要求较高，建议将这里换成int children[8]以提高效率。</span>
  vector&lt;<span class="dt">int</span>&gt; children;

  get_children(x, &amp;children);
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; children.size(); ++i) {
    <span class="kw">if</span> (Solve(children[i], depth + <span class="dv">1</span>)) <span class="kw">return</span> <span class="kw">true</span>;
  }

  visit[x] = <span class="kw">false</span>;
  <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">void</span> get_children(<span class="dt">int</span> x, vector&lt;<span class="dt">int</span>&gt; *children) {
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; neighbors[x].size(); ++i) {
    <span class="dt">int</span> child = neighbors[x][i];
    <span class="kw">if</span> (!visit[child]) {
      children-&gt;push_back(child);
    }
  }
}</code></pre>
</div><div id="马周游-缺点" class="slide section level2">
<h1>1152 1153 马周游 缺点</h1>
<div class="incremental">
<p>程序过慢，只能勉强过1152</p>
</div>
<div class="incremental">
<p>优化：改变搜索顺序</p>
<p>先搜索可行格较少的格子</p>
<table>
<tbody>
<tr class="odd">
<td align="left">x</td>
<td align="center">.</td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr class="even">
<td align="left">x</td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">.</td>
<td align="center">.</td>
</tr>
<tr class="odd">
<td align="left">.</td>
<td align="center">x</td>
<td align="center">?(2)</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr class="even">
<td align="left"><strong>x</strong></td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">.</td>
<td align="center">.</td>
</tr>
<tr class="odd">
<td align="left">x</td>
<td align="center">.</td>
<td align="center">?(1)</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
</tbody>
</table>
</div>
</div><div id="马周游-代码-1" class="slide section level2">
<h1>1152 1153 马周游 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> cnt_size[<span class="dv">64</span>];

<span class="dt">bool</span> cmp(<span class="dt">int</span> x, <span class="dt">int</span> y) {
  <span class="kw">return</span> cnt_size[x] &lt; cnt_size[y];
}

<span class="dt">int</span> get_children_size(<span class="dt">int</span> x) {
  <span class="dt">int</span> size = <span class="dv">0</span>;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; neighbors[x].size(); ++i) {
    <span class="dt">int</span> child = neighbors[x][i];
    <span class="kw">if</span> (!visit[child]) {
      ++size;
    }
  }
  <span class="kw">return</span> size;
}

<span class="dt">void</span> get_children(<span class="dt">int</span> x, vector&lt;<span class="dt">int</span>&gt; *children) {
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; neighbors[x].size(); ++i) {
    <span class="dt">int</span> child = neighbors[x][i];
    <span class="kw">if</span> (!visit[child]) {
      children-&gt;push_back(child);
      cnt_size[child] = get_children_size(child);
    }
  }
  sort(children-&gt;begin(), children-&gt;end(), cmp);
}</code></pre>
</div><div id="马周游-解题报告" class="slide section level2">
<h1>1152 1153 马周游 解题报告</h1>
<ul class="incremental">
<li><p>可在解题报告中尝试其他搜索顺序或剪枝，对比其效果</p></li>
<li><p>通过加大数据范围，如扩展到9x9, 10x10，本地跑程序来对比不同算法的性能</p></li>
<li><p>可以思考构造性的算法</p></li>
</ul>
</div>
<div id="air-express" class="titleslide slide section level1"><h1>1093 Air Express</h1></div><div id="air-express-题目大意" class="slide section level2">
<h1>1093 Air Express 题目大意</h1>
<p>给出4个重量区间 &amp; 每个区间的单位重量运输价格</p>
<table>
<thead>
<tr class="header">
<th align="left">Package weight</th>
<th align="center">Cost per pound</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0 to 9 pounds</td>
<td align="center">$10</td>
</tr>
<tr class="even">
<td align="left">10 to 49 pounds</td>
<td align="center">$5</td>
</tr>
<tr class="odd">
<td align="left">50 to 99 pounds</td>
<td align="center">$3</td>
</tr>
<tr class="even">
<td align="left">100 pounds or more</td>
<td align="center">$2</td>
</tr>
</tbody>
</table>
<p>有一个背包需要运输，问往背包里面添加多少重量后可以让运费最低</p>
</div><div id="air-express-解题思路" class="slide section level2">
<h1>1093 Air Express 解题思路</h1>
<table>
<thead>
<tr class="header">
<th align="left">Package weight</th>
<th align="center">Cost per pound</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0 to 9 pounds</td>
<td align="center">$10</td>
</tr>
<tr class="even">
<td align="left">10 to 49 pounds</td>
<td align="center">$5</td>
</tr>
<tr class="odd">
<td align="left">50 to 99 pounds</td>
<td align="center">$3</td>
</tr>
<tr class="even">
<td align="left">100 pounds or more</td>
<td align="center">$2</td>
</tr>
</tbody>
</table>
<p>最小运输价格必定出现在：</p>
<ol class="incremental" style="list-style-type: decimal">
<li>不添加任何重量</li>
<li>添加重量后刚好到达某个区间的下界</li>
</ol>
</div><div id="air-express-代码" class="slide section level2">
<h1>1093 Air Express 代码</h1>
<div class="incremental">
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> cal(<span class="dt">int</span> weight) {
  <span class="dt">int</span> price = INF;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">4</span>; i++) {
    <span class="kw">if</span> (lower[i] &lt;= weight &amp;&amp; weight &lt;= upper[i]) {
      price = min(price, weigth * rate[i]);
    } <span class="kw">else</span> <span class="kw">if</span> (weight &lt; lower[i]) {
      price = min(price, lower[i] * rate[i]);
    }
  }
  <span class="kw">return</span> price;
}</code></pre>
</div>
<div class="incremental">
<p>修改这段代码让它输出需要添加的重量</p>
</div>
</div>
<div id="积木分发" class="titleslide slide section level1"><h1>1134 积木分发</h1></div><div id="积木分发-题目大意" class="slide section level2">
<h1>1134 积木分发 题目大意</h1>
<p>n个小伙伴，每个人手上有<span class="math">\(a_i\)</span>块积木，还需要<span class="math">\(b_i\)</span>块积木才能完成任务</p>
<p>The Pancakes手上有s块积木，她可以把她手中的积木都给某个人，等那个人完成任务后回收他手上的所有积木</p>
<p>问The Pancakes最后是否能回收完所有人的积木</p>
<p><span class="math">\(s \le 10^6, n \le 10^4, a, b \le 10^9\)</span></p>
</div><div id="积木分发-样例" class="slide section level2">
<h1>1134 积木分发 样例</h1>
<div class="incremental">
<p>第一个样例：</p>
<p>n = 2, s = 2</p>
<p>a = 1, b = 4</p>
<p>a = 2, b = 1</p>
<p>分给第二个人 -&gt; s = 4 -&gt; 再分给第一个人 -&gt; s = 5</p>
</div>
<div class="incremental">
<p>第二个样例：</p>
<p>n = 2, s = 2</p>
<p>a = 1, b = 4</p>
<p>a = 1, b = 1</p>
<p>分给第二个人 -&gt; s = 3 -&gt; 第一人仍然不够，失败</p>
</div>
</div><div id="积木分发-解题思路" class="slide section level2">
<h1>1134 积木分发 解题思路</h1>
<div class="incremental">
<p>应该先分给需求少的人，因为分完后The Pancakes手上的积木总是会变多的</p>
</div>
<div class="incremental">
<p>排序后贪心求解</p>
</div>
</div><div id="积木分发-代码" class="slide section level2">
<h1>1134 积木分发 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Node {
  <span class="dt">int</span> have, need;
};
<span class="dt">bool</span> <span class="kw">operator</span>&lt;(<span class="dt">const</span> Node&amp; x, <span class="dt">const</span> Node&amp; y) {
  <span class="kw">return</span> x.need &lt; y.need;
}
<span class="dt">bool</span> Solve() {
  sort(nodes, nodes + n);
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
    <span class="kw">if</span> (s &lt; nodes[i].need) <span class="kw">return</span> <span class="kw">false</span>;
    s += nodes[i].have;
  }
  <span class="kw">return</span> <span class="kw">true</span>;
}</code></pre>
</div>
<div id="国王的遗产" class="titleslide slide section level1"><h1>1140 国王的遗产</h1></div><div id="国王的遗产-题目大意" class="slide section level2">
<h1>1140 国王的遗产 题目大意</h1>
<p>一棵由n块金块组成的树</p>
<p>k个人按顺序轮流拿金块，每个人拿的时候选择树的一条边将其分割成两棵树</p>
<div id="king1">

</div>
</div><div id="国王的遗产-题目大意-1" class="slide section level2">
<h1>1140 国王的遗产 题目大意</h1>
<div id="king2">

</div>
<p>拿的那部分的金块数不能超过当前金块总数的一半</p>
<p>每个人都希望拿到尽量多的金块</p>
<p>如果有多种拿法，则拿最小金块编号最小的那一块</p>
</div><div id="国王的遗产-题目大意-2" class="slide section level2">
<h1>1140 国王的遗产 题目大意</h1>
<div id="king3">

</div>
<script src="lecture.js"></script>
<script>
graph_king = {
nodes: [
       {name: 1, color: "#66ccff"},
       {name: 2, color: "#66ccff"},
       {name: 3, color: "#66ccff"},
       {name: 4, color: "#66ccff"},
       {name: 5, color: "#66ccff"},
       {name: 6, color: "#66ccff"},
       ],
       edges: [
       {source: 0, target: 1},
       {source: 1, target: 2},
       {source: 2, target: 3},
       {source: 1, target: 4},
       {source: 2, target: 5}
       ]
};

var w = 500;
var h = 300;
var svg = d3.select("div#king1").append("svg")
.attr('viewBox', "0 0 " + w + " " + h)
.attr('preserveAspectRatio', "xMinYMin meet")
.attr('width', w).attr('height', h);
GraphKing.createNew(svg, w, h, graph_king);

graph_king = {
nodes: [
       {name: 1, color: "yellow"},
       {name: 2, color: "yellow"},
       {name: 3, color: "#66ccff"},
       {name: 4, color: "#66ccff"},
       {name: 5, color: "yellow"},
       {name: 6, color: "#66ccff"},
       ],
       edges: [
       {source: 0, target: 1},
       {source: 2, target: 3},
       {source: 1, target: 4},
       {source: 2, target: 5}
       ]
};

var svg = d3.select("div#king2").append("svg")
.attr('width', w).attr('height', h);
GraphKing.createNew(svg, w, h, graph_king);

graph_king = {
nodes: [
       {name: 1, color: "yellow"},
       {name: 2, color: "yellow"},
       {name: 3, color: "#66ccff"},
       {name: 4, color: "orange"},
       {name: 5, color: "yellow"},
       {name: 6, color: "#66ccff"},
       ],
       edges: [
       {source: 0, target: 1},
       {source: 1, target: 4},
       {source: 2, target: 5}
       ]
};

var svg = d3.select("div#king3").append("svg")
.attr('width', w).attr('height', h);
GraphKing.createNew(svg, w, h, graph_king);

</script>

</div><div id="国王的遗产-题目大意-3" class="slide section level2">
<h1>1140 国王的遗产 题目大意</h1>
<pre><code>6 3
1 2
2 3
3 4
2 5
3 6

3 1 2</code></pre>
<p><span class="math">\(n \le 30000, k \le 100\)</span></p>
</div><div id="国王的遗产-解题思路" class="slide section level2">
<h1>1140 国王的遗产 解题思路</h1>
<div class="incremental">
<p>按顺序做，枚举每一个人，检查切断每一条边所得到的两棵子树，计算其节点数和最小编号</p>
<p>如何得到这两棵子树？</p>
</div>
<div class="incremental">
<p>去掉边后做DFS</p>
<p>复杂度？</p>
</div>
<div class="incremental">
<p><span class="math">\(O(N^2 K)\)</span>, 枚举边 * DFS求大小 * K次，无法承受</p>
</div>
</div><div id="国王的遗产-解题思路-1" class="slide section level2">
<h1>1140 国王的遗产 解题思路</h1>
<p>转化成有根树，只需要做一次DFS</p>
<div id="king4">

</div>
<script>
graph_king = {
nodes: [
       {name: "1 [5]", color: "#66ccff"},
       {name: "2 [4]", color: "#66ccff"},
       {name: "3 [2]", color: "#66ccff"},
       {name: "4 [0]", color: "#66ccff"},
       {name: "5 [0]", color: "#66ccff"},
       {name: "6 [0]", color: "#66ccff"},
       ],
       edges: [
       {source: 0, target: 1},
       {source: 1, target: 2},
       {source: 2, target: 3},
       {source: 1, target: 4},
       {source: 2, target: 5}
       ]
};

var w = 500;
var h = 300;
var svg = d3.select("div#king4").append("svg")
.attr('viewBox', "0 0 " + w + " " + h)
.attr('preserveAspectRatio', "xMinYMin meet")
.attr('width', w).attr('height', h);
GraphKing.createNew(svg, w, h, graph_king);
</script>


</div><div id="国王的遗产-代码" class="slide section level2">
<h1>1140 国王的遗产 代码</h1>
<p>记录子树的大小，删除的边的两个端点，子树中的最小编号</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> SubTree {
  <span class="dt">int</span> num_nodes;
  <span class="dt">int</span> insider, outsider;
  <span class="dt">int</span> min_id;
};</code></pre>
<p>用vector<int>来保存树的边</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span> kMaxN = <span class="dv">31000</span>;
vector&lt;<span class="dt">int</span>&gt; G[kMaxN];
SubTree subtree[kMaxN];</code></pre>
</div><div id="国王的遗产-代码-1" class="slide section level2">
<h1>1140 国王的遗产 代码</h1>
<p>不同子树之间的比较：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> <span class="kw">operator</span>&lt;(<span class="dt">const</span> SubTree&amp; a, <span class="dt">const</span> SubTree&amp; b) {
  <span class="kw">if</span> (a.num_nodes != b.num_nodes) {
    <span class="kw">return</span> a.num_nodes &gt; b.num_nodes;
  }
  <span class="kw">return</span> a.min_id &lt; b.min_id;
}</code></pre>
<p>主过程：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;<span class="dt">int</span>&gt; ans;
pivot = <span class="dv">0</span>;
total = n;
<span class="kw">for</span> (<span class="dt">int</span> ichild = <span class="dv">0</span>; ichild &lt; num_children - <span class="dv">1</span>; ++ichild) {
  pivot = dfs_find_min(pivot, -<span class="dv">1</span>);

  best.num_nodes = -<span class="dv">1</span>;
  dfs(pivot, -<span class="dv">1</span>);
  ans.push_back(best.num_nodes);

  <span class="co">// Remove edge best.insider &lt;-&gt; best.outsider</span>

  total -= best.num_nodes;
  pivot = best.outsider;
}</code></pre>
</div><div id="国王的遗产-代码-2" class="slide section level2">
<h1>1140 国王的遗产 代码</h1>
<p>找出树中的最小编号，从该编号开始DFS</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> dfs_find_min(<span class="dt">int</span> x, <span class="dt">int</span> parent) {
  <span class="dt">int</span> min_id = x;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; G[x].size(); ++i) {
    <span class="dt">int</span> child = G[x][i];
    <span class="kw">if</span> (child == parent) <span class="kw">continue</span>;
    min_id = min(min_id, dfs_find_min(child, x));
  }
  <span class="kw">return</span> min_id;
}</code></pre>
</div><div id="国王的遗产-代码-3" class="slide section level2">
<h1>1140 国王的遗产 代码</h1>
<p>主DFS过程</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> total;
<span class="dt">int</span> pivot;
SubTree best;
<span class="dt">void</span> dfs(<span class="dt">int</span> x, <span class="dt">int</span> parent) {
  subtree[x].num_nodes = <span class="dv">1</span>;
  subtree[x].min_id = x;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; G[x].size(); ++i) {
    <span class="dt">int</span> child = G[x][i];
    <span class="kw">if</span> (child == parent) <span class="kw">continue</span>;
    dfs(child, x);
    subtree[x].num_nodes += subtree[child].num_nodes;
    subtree[x].min_id = min(subtree[x].min_id, subtree[child].min_id);
  }
  <span class="kw">if</span> (x != pivot) {
    subtree[x].outsider = parent;
    subtree[x].insider = x;
    <span class="kw">if</span> (subtree[x].num_nodes &lt;= total / <span class="dv">2</span>) {
      best = min(best, subtree[x]);
    }
    SubTree subtree2;
    subtree2.num_nodes = total - subtree[x].num_nodes;
    subtree2.min_id = pivot;
    subtree2.insider = parent;
    subtree2.outsider = x;
    <span class="kw">if</span> (subtree2.num_nodes &lt;= total / <span class="dv">2</span>) {
      best = min(best, subtree2);
    }
  }
}</code></pre>
</div>
<div id="shopaholic" class="titleslide slide section level1"><h1>1438 Shopaholic</h1></div><div id="shopaholic-题目大意" class="slide section level2">
<h1>1438 Shopaholic 题目大意</h1>
<p>买东西 每买三件东西 最便宜的一件免费</p>
<p>给出n个需要买的东西</p>
<p>问最多免费多少？</p>
<p><span class="math">\(n \le 20000, price \le 20000\)</span></p>
</div><div id="shopaholic-样例" class="slide section level2">
<h1>1438 Shopaholic 样例</h1>
<p>6</p>
<p>400 100 200 350 300 250</p>
<p>(400 350 300) (250 200 100) =&gt; 400</p>
</div><div id="shopaholic-解题思路" class="slide section level2">
<h1>1438 Shopaholic 解题思路</h1>
<div class="incremental">
<p>尽量使价格高的东西免费</p>
</div>
<div class="incremental">
<p>按价格从高到低排序，每三件取一件免费</p>
</div>
<div class="incremental">
<p>严格证明？考虑最便宜的商品，必须找两个和它配对</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">sort(price, price + n, greater&lt;<span class="dt">int</span>&gt;());
<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">2</span>; i &lt; n; i += <span class="dv">3</span>) {
  saved += price[i];
}</code></pre>
</div>
</div>
<div id="hanoi-tower-sequence" class="titleslide slide section level1"><h1>1028 Hanoi Tower Sequence</h1></div><div id="hanoi-tower-sequence-题目大意" class="slide section level2">
<h1>1028 Hanoi Tower Sequence 题目大意</h1>
<div class="incremental">
<p>汉诺塔：三个柱子和大小两两不同的盘子放在一个柱子上</p>
<p>目的：将这些盘子移动到另外一个柱子上</p>
<p>规则：每次只能移动最顶端的一个盘子，每次移动后较小的盘子必须放在较大的盘子上面</p>
</div>
<div class="incremental">
<p>现在给出步数p，问第p步移动的盘子的大小</p>
<p><span class="math">\(p \le 10^{100}\)</span></p>
</div>
</div><div id="hanoi-tower-sequence-题目大意-1" class="slide section level2">
<h1>1028 Hanoi Tower Sequence 题目大意</h1>
<div class="figure">
<img src="1028.png" alt="规则" /><p class="caption">规则</p>
</div>
<ol class="incremental" style="list-style-type: decimal">
<li>把前n - 1个盘子移到第二根柱子上</li>
<li>把第n个盘子移到第三根柱子上</li>
<li>把前n - 1个盘子移到第三根柱子上</li>
</ol>
</div><div id="hanoi-tower-sequence-解题思路" class="slide section level2">
<h1>1028 Hanoi Tower Sequence 解题思路</h1>
<div class="incremental">
<p>先递归求解总步数</p>
<p>设移动k个盘子需要f(k)步，则有：</p>
<p>f(k) = f(k - 1) + 1 + f(k - 1)</p>
<p>f(1) = 1</p>
<p>所以：</p>
</div>
<div class="incremental">
<p><span class="math">\(f(k) = 2^k - 1\)</span></p>
</div>
</div><div id="hanoi-tower-sequence-解题思路-1" class="slide section level2">
<h1>1028 Hanoi Tower Sequence 解题思路</h1>
<p>发现：</p>
<p>第<span class="math">\(2^k\)</span>步移动的是第k + 1个盘子</p>
</div><div id="hanoi-tower-sequence-解题思路-2" class="slide section level2">
<h1>1028 Hanoi Tower Sequence 解题思路</h1>
<div class="incremental">
<p>找规律</p>
<pre><code>1
1 2 1
1 2 1 3 1 2 1
1 2 1 3 1 2 1 4 1 2 1 3 1 2 1
1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 </code></pre>
<p>具有自相似的特性</p>
</div>
<div class="incremental">
<pre><code>0001 =&gt; 0
0010 =&gt; 1
0011 =&gt; 0
0100 =&gt; 2
0101 =&gt; 0
0110 =&gt; 1
0111 =&gt; 0
1000 =&gt; 3
1001 =&gt; 0
1010 =&gt; 1
1011 =&gt; 0
1100 =&gt; 2
1101 =&gt; 0
1110 =&gt; 1
1111 =&gt; 0</code></pre>
</div>
</div><div id="hanoi-tower-sequence-解题思路-3" class="slide section level2">
<h1>1028 Hanoi Tower Sequence 解题思路</h1>
<p>答案为把p表示成2进制数，最后有多少个零，再加1</p>
<p>假设x是读进来的数字，x[n - 1]是最低位：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> ans = <span class="dv">1</span>;
<span class="kw">while</span> (x[n - <span class="dv">1</span>] % <span class="dv">2</span> == <span class="dv">0</span>) {
  ++ans;

  <span class="co">// 除2</span>
  <span class="dt">int</span> remain = <span class="dv">0</span>;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
    remain = remain * <span class="dv">10</span> + x[i];
    x[i] = remain / <span class="dv">2</span>;
    remain %= <span class="dv">2</span>;
  }
  assert(remain == <span class="dv">0</span>);
}</code></pre>
</div>
<div id="rabbit" class="titleslide slide section level1"><h1>1029 Rabbit</h1></div><div id="rabbit-题目大意" class="slide section level2">
<h1>1029 Rabbit 题目大意</h1>
<p>开始有一对成年兔子</p>
<p>每对成年兔子每个月产生一对小兔子</p>
<p>每只小兔子经过m个月变成成年兔子</p>
<p>问经过d个月后有多少兔子</p>
<p><span class="math">\(1 \le m \le 10, 1 \le d \le 100\)</span></p>
</div><div id="rabbit-题目大意-1" class="slide section level2">
<h1>1029 Rabbit 题目大意</h1>
<p>m = 2时是经典的Fibonacci问题</p>
</div><div id="rabbit-解题思路" class="slide section level2">
<h1>1029 Rabbit 解题思路</h1>
<div class="incremental">
<p>每个月的兔子数量 = 上个月兔子数量 + 这个月出生的小兔子数量</p>
</div>
<div class="incremental">
<p>小兔子由大兔子生育得到，这些大兔子在m个月前就必须存在了</p>
<p>每个月的兔子数量 = 上个月兔子数量 + m个月前的兔子数量</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">dp[n] = dp[n - <span class="dv">1</span>] + dp[n - m]</code></pre>
</div>
</div><div id="rabbit-代码" class="slide section level2">
<h1>1029 Rabbit 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> BigInteger {
  <span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> kMaxLen = <span class="dv">100</span>;
  <span class="dt">int</span> x[kMaxLen];
  BigInteger(<span class="dt">int</span> a = <span class="dv">0</span>) {
    memset(x, <span class="dv">0</span>, <span class="kw">sizeof</span> (x));
    x[<span class="dv">0</span>] = a;
  }
};

<span class="co">// 效率较低，只做演示用！</span>
BigInteger <span class="kw">operator</span>+(<span class="dt">const</span> BigInteger&amp; a, <span class="dt">const</span> BigInteger&amp; b) {
  BigInteger c;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; kMaxLen - <span class="dv">1</span>; ++i) {
    c.x[i] += a.x[i] + b.x[i];
    c.x[i + <span class="dv">1</span>] += c.x[i] / <span class="dv">10</span>;
    c.x[i] %= <span class="dv">10</span>;
  }
  <span class="kw">return</span> c;
}

dp[<span class="dv">0</span>] = BigInteger(<span class="dv">1</span>);
<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= d; ++i) {
  <span class="kw">if</span> (i &lt; m) {
    a[i] = a[i - <span class="dv">1</span>] + BigInteger(<span class="dv">1</span>);
  } <span class="kw">else</span> {
    a[i] = a[i - <span class="dv">1</span>] + a[i - m];
  }
}</code></pre>
</div>
<div id="ab" class="titleslide slide section level1"><h1>1381 a*b</h1></div><div id="ab-题目大意" class="slide section level2">
<h1>1381 a*b 题目大意</h1>
<p>给两个整数a和b，求<span class="math">\(a \times b\)</span></p>
<p><span class="math">\(0 \le a \le 10^{100}, 0 \le b \le 10000\)</span></p>
<p>a, b都有可能是0</p>
</div><div id="ab-解题思路" class="slide section level2">
<h1>1381 a*b 解题思路</h1>
<p>高精度乘法，模拟竖式乘法</p>
<p>输出时注意前导0和0的情况</p>
</div><div id="ab-代码" class="slide section level2">
<h1>1381 a*b 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> BigInteger {
  <span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> kMaxLen = <span class="dv">120</span>;
  <span class="dt">int</span> x[kMaxLen];
  BigInteger(<span class="dt">int</span> a = <span class="dv">0</span>) {
    memset(x, <span class="dv">0</span>, <span class="kw">sizeof</span> (x));
    x[<span class="dv">0</span>] = a;
  }
  BigInteger <span class="kw">operator</span>*(<span class="dt">int</span> b) <span class="dt">const</span> {
    BigInteger res(<span class="dv">0</span>);
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; kMaxLen; i++) {
      res.x[i] += x[i] * b;
      res.x[i + <span class="dv">1</span>] += c.x[i] / <span class="dv">10</span>;
      res.x[i] %= <span class="dv">10</span>;
    }
    <span class="kw">return</span> res;
  }
};</code></pre>
<p>以此为基础，可自行练习大整数乘大整数的程序。</p>
<p>另外，这两个大整数程序都以10为进位， 实际使用时可以用10000为进位数，把4个数字压在一个数组中，可以明显提高程序效率。</p>
</div>
<div id="stacking-cylinders" class="titleslide slide section level1"><h1>1206 1012 Stacking Cylinders</h1></div><div id="stacking-cylinders-题目大意" class="slide section level2">
<h1>1206 1012 Stacking Cylinders 题目大意</h1>
<p>给出最底层的n个圆柱的位置，求最顶层的圆柱的位置</p>
<p>圆柱半径都为1</p>
<p><span class="math">\(1 \le n \le 10\)</span></p>
<div class="figure">
<img src="1206.jpg" alt="如图" /><p class="caption">如图</p>
</div>
</div><div id="stacking-cylinders-解题思路" class="slide section level2">
<h1>1206 1012 Stacking Cylinders 解题思路</h1>
<p>已知两个圆的圆心坐标，求放在这两个圆上的圆的圆心坐标</p>
<p>向量 勾股定理</p>
</div><div id="stacking-cylinders-complex库" class="slide section level2">
<h1>1206 1012 Stacking Cylinders complex库</h1>
<p>STL中的复数库可以简化代码</p>
<p>复数的旋转：<span class="math">\(a \times e^{i \theta}\)</span></p>
<p>两个点之间的距离：<span class="math">\(\|a - b\|\)</span></p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">complex&lt;<span class="dt">double</span>&gt; a, b;
b = a * exp(complex&lt;<span class="dt">double</span>&gt;(<span class="dv">0</span>, t));  <span class="co">//旋转角度为t</span>
b = a * complex&lt;<span class="dt">double</span>&gt;(<span class="dv">0</span>, <span class="dv">1</span>);  <span class="co">//旋转90度</span>
sqrt(norm(a - b));  <span class="co">// 两点之间的距离</span>
abs(a - b);  <span class="co">// 或者</span>
a.real();  <span class="co">// x坐标</span>
a.imag();  <span class="co">// y坐标</span></code></pre>
</div><div id="stacking-cylinders-代码" class="slide section level2">
<h1>1206 1012 Stacking Cylinders 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> complex&lt;<span class="dt">double</span>&gt; Point;

<span class="dt">bool</span> cmp(<span class="dt">const</span> Point&amp; a, <span class="dt">const</span> Point&amp; b) {
  <span class="kw">return</span> a.real() &lt; b.real();
}

Point Calculate(<span class="dt">const</span> Point&amp; a, <span class="dt">const</span> Point&amp; b) {
  Point mid = (a + b) / Point(<span class="dv">2</span>, <span class="dv">0</span>);
  Point height = (b - mid) * Point(<span class="dv">0</span>, <span class="dv">1</span>);
  <span class="dt">double</span> len = sqrt(<span class="dv">4</span> - norm(a - mid));
  height = height / abs(height) * len;
  <span class="kw">return</span> mid + height;
}

sort(points, points + n, cmp);
<span class="kw">for</span> (<span class="dt">int</span> len = n - <span class="dv">1</span>; len &gt;= <span class="dv">1</span>; --len) {
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; len; ++i) {
    points[i] = Calculate(points[i], points[i + <span class="dv">1</span>]);
  }
}</code></pre>
</div>
<div id="queens-knights-and-pawns" class="titleslide slide section level1"><h1>1172 Queens, Knights and Pawns</h1></div><div id="queens-knights-and-pawns-题目大意" class="slide section level2">
<h1>1172 Queens, Knights and Pawns 题目大意</h1>
<p>给一个棋盘，若干后、马和兵的位置</p>
<p>求棋盘上有多个没被占领的格子不会受到后也不会受到马的攻击</p>
<p>棋盘大小<span class="math">\(1000 \times 1000\)</span>，每种棋子最多100个</p>
</div><div id="queens-knights-and-pawns-解题思路" class="slide section level2">
<h1>1172 Queens, Knights and Pawns 解题思路</h1>
<p>用二维数组表示一个棋盘</p>
<p>标记每个棋子的位置</p>
<p>再标记每个棋子能攻击的位置</p>
<p>最后计算有多少个位置不会被攻击</p>
</div><div id="queens-knights-and-pawns-代码" class="slide section level2">
<h1>1172 Queens, Knights and Pawns 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">enum</span> GridState {
  empty,
  occupied,
  attacked
};

<span class="dt">const</span> <span class="dt">int</span> kMaxN = <span class="dv">1024</span>;
GridState grid[kMaxN][kMaxN];

<span class="dt">void</span> occupy(vector&lt;Point&gt; v) {
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; v.size(); i++) {
    grid[v[i].x][v[i].y]] = occupied;
  }
}

<span class="dt">bool</span> in_board_and_unoccupied(Point p) {
  <span class="kw">if</span> (<span class="dv">1</span> &lt;= p.x &amp;&amp; p.x &lt;= num_row) {
    <span class="kw">if</span> (<span class="dv">1</span> &lt;= p.y &amp;&amp; p.y &lt;= num_col) {
      <span class="kw">return</span> grid[p.x][p.y]!=occupied;
    }
  }
  <span class="kw">return</span> <span class="kw">false</span>;
}</code></pre>
</div><div id="queens-knights-and-pawns-代码-1" class="slide section level2">
<h1>1172 Queens, Knights and Pawns 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="dt">int</span> dKnight[<span class="dv">8</span>][<span class="dv">2</span>] = {{<span class="dv">1</span>,<span class="dv">2</span>},{<span class="dv">1</span>,-<span class="dv">2</span>},{<span class="dv">2</span>,-<span class="dv">1</span>},{-<span class="dv">2</span>,-<span class="dv">1</span>},{-<span class="dv">1</span>,-<span class="dv">2</span>},{-<span class="dv">1</span>,<span class="dv">2</span>},{-<span class="dv">2</span>,<span class="dv">1</span>},{<span class="dv">2</span>,<span class="dv">1</span>}};
<span class="dt">int</span> dQueen[<span class="dv">8</span>][<span class="dv">2</span>] = {{<span class="dv">1</span>,<span class="dv">0</span>},{<span class="dv">1</span>,-<span class="dv">1</span>},{<span class="dv">0</span>,-<span class="dv">1</span>},{-<span class="dv">1</span>,-<span class="dv">1</span>},{-<span class="dv">1</span>,<span class="dv">0</span>},{-<span class="dv">1</span>,<span class="dv">1</span>},{<span class="dv">0</span>,<span class="dv">1</span>},{<span class="dv">1</span>,<span class="dv">1</span>}};

<span class="dt">void</span> KnightAttack(vector&lt;Point&gt; points) {
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; points.size(); i++) {
    <span class="kw">for</span> (<span class="dt">int</span> dir = <span class="dv">0</span>; dir &lt; <span class="dv">8</span>; dir++) {
      Point newp(points[i].x + dKnight[dir][<span class="dv">0</span>], points[i].y + dKnight[dir][<span class="dv">1</span>]);
      <span class="kw">if</span> (in_board_and_unoccupied(newp)) {
        grid[newp.x][newp.y] = attacked;
      }
    }
  }
}

<span class="dt">void</span> QueenAttack(vector&lt;Point&gt; points) {
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; points.size(); i++) {
    <span class="kw">for</span> (<span class="dt">int</span> dir = <span class="dv">0</span>; dir &lt; <span class="dv">8</span>; dir++) {
      Point newp(points[i].x + dQueen[dir][<span class="dv">0</span>], points[i].y + dQueen[dir][<span class="dv">1</span>]);
      <span class="kw">while</span> (in_board_and_unoccupied(newp)) {
        grid[newp.x][newp.y] = attacked;
        newp(newp.x + dQueen[dir][<span class="dv">0</span>], newp + dQueen[dir][<span class="dv">1</span>]);
      }
    }
  }
}</code></pre>
</div><div id="queens-knights-and-pawns-代码-2" class="slide section level2">
<h1>1172 Queens, Knights and Pawns 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp">memset(grid, <span class="dv">0</span>, <span class="kw">sizeof</span>(grid));
occupy(queen);
occupy(knight);
occupy(pawn);

KnightAttack(knight);
QueenAttack(queen);

<span class="dt">int</span> ans = <span class="dv">0</span>;
<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= num_row; i++) {
  <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= num_col; j++) {
    <span class="kw">if</span> (grid[i][j] == empty) {
      ans++;
    }
  }
}</code></pre>
</div>
<div id="forest" class="titleslide slide section level1"><h1>1034 Forest</h1></div><div id="forest-题目大意" class="slide section level2">
<h1>1034 Forest 题目大意</h1>
<p>n个节点</p>
<p>m条有向边</p>
<p>判断是否组成森林，如果是，求出它的最大深度和最大宽度</p>
<p><span class="math">\(n, m \le 100\)</span></p>
</div><div id="forest-解题思路" class="slide section level2">
<h1>1034 Forest 解题思路</h1>
<div class="incremental">
<p>有根树，边的方向已经确定</p>
</div>
<div class="incremental">
<p>判断是否为森林：</p>
<ul class="incremental">
<li>没有一个节点的入度超过1</li>
<li>计算深度值时没有出现矛盾</li>
<li>没有环</li>
</ul>
<p>具体做法：</p>
<p>入度为0的点都做DFS，为每个点计算深度，判断最后是否所有的点都被访问到</p>
</div>
</div><div id="forest-代码" class="slide section level2">
<h1>1034 Forest 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span> kMaxN = <span class="dv">128</span>;
vector&lt;<span class="dt">int</span>&gt; G[kMaxN];
<span class="dt">int</span> depth[kMaxN];  <span class="co">// -1: invalid</span>
<span class="dt">int</span> count_depth[kMaxN];
<span class="dt">int</span> indegree[kMaxN];

<span class="dt">bool</span> dfs(<span class="dt">int</span> x, <span class="dt">int</span> parent, <span class="dt">int</span> d) {
  depth[x] = d;
  ++count_depth[d];
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; G[x].size(); ++i) {
    <span class="dt">int</span> child = G[x][i];
    <span class="kw">if</span> (child == parent) <span class="kw">continue</span>;
    <span class="kw">if</span> (depth[child] != -<span class="dv">1</span>) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">if</span> (!dfs(child, x, d + <span class="dv">1</span>)) {
      <span class="kw">return</span> <span class="kw">false</span>;
    }
  }
  <span class="kw">return</span> <span class="kw">true</span>;
}</code></pre>
<pre class="sourceCode cpp"><code class="sourceCode cpp">memset(depth, -<span class="dv">1</span>, <span class="kw">sizeof</span> (depth));  <span class="co">// only the value -1, 0 can be memseted</span>
memset(count_depth, <span class="dv">0</span>, <span class="kw">sizeof</span> (count_depth));
<span class="dt">bool</span> is_forest = <span class="kw">true</span>;
<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
  <span class="kw">if</span> (indegree[i] == <span class="dv">0</span>) {
    <span class="kw">if</span> (!dfs(i, -<span class="dv">1</span>, <span class="dv">0</span>)) {
      is_forest = <span class="kw">false</span>;
      <span class="kw">break</span>;
    }
  } <span class="kw">else</span> <span class="kw">if</span> (indegree[i] != <span class="dv">1</span>) {
    is_forest = <span class="kw">false</span>;
    <span class="kw">break</span>;
  }
}
<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) <span class="kw">if</span> (depth[i] &lt; <span class="dv">0</span>) {
  is_forest = <span class="kw">false</span>;
}</code></pre>
</div>
<div id="up-the-stairs" class="titleslide slide section level1"><h1>1193 Up the Stairs</h1></div><div id="up-the-stairs-题目大意" class="slide section level2">
<h1>1193 Up the Stairs 题目大意</h1>
<div class="incremental">
<p>N个人在F层之间搬箱子</p>
<p>开始时每个人都位于某一层上，要么手头拿着箱子，要么没有</p>
<p>拿着箱子的人会往上走，没拿的会往下走</p>
<p>当两个人相遇时，拿着箱子的人会把箱子交给没有箱子的人，互换方向继续走</p>
<p>走到F层的人把箱子放下，走到0层的人把箱子拿起来</p>
<p>初始时，0层有B个箱子，问多少时间后，所有箱子都在F层</p>
</div>
<div class="incremental">
<p>| 0, B boxes | 1 | 2 | ... | <span class="math">\(\blacksquare \rightarrow\)</span> | ... | <span class="math">\(\leftarrow \Box\)</span> | ... | F-1 | F |</p>
<p>| 0, B boxes | 1 | 2 | ... | <span class="math">\(\leftarrow \Box\)</span> | ... | <span class="math">\(\blacksquare \rightarrow\)</span> | ... | F-1 | F |</p>
<p><span class="math">\(1 \le N, F \le 1000, 1 \le B \le 10^6\)</span></p>
</div>
</div><div id="up-the-stairs-解题思路" class="slide section level2">
<h1>1193 Up the Stairs 解题思路</h1>
<p>两个人交换箱子互换方向，相当于互相穿过没有交换</p>
</div>
</body>
</html>
