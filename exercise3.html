<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="chyx111@qq.com" />
  <title>算法分析习题选讲(第三章)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">MathJax.Hub.Queue(["Typeset",MathJax.Hub]);</script>
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">算法分析习题选讲(第三章)</h1>
  <p class="author">
chyx111@qq.com
  </p>
</div>
<div id="马周游" class="titleslide slide section level1"><h1>1152 1153 马周游</h1></div><div id="马周游-题目大意" class="slide section level2">
<h1>1152 1153 马周游 题目大意</h1>
<p>一个有限大小的棋盘上有一只马</p>
<p>给出初始时马的位置，找出一条马移动的路线，经过所有格子各一次</p>
<div id="knight">

</div>
<script src="raphael.js"></script>
<script src="d3.v3.min.js"></script>
<script src="lecture.js"></script>
<script>
var w = h = 500;
var svg = d3.select("div#knight").append("svg")
.attr("width", w).attr("height", h);
KnightBoard.createNew(svg, w, h);
</script>

</div><div id="马周游-题目大意-1" class="slide section level2">
<h1>1152 1153 马周游 题目大意</h1>
<table>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="left"><strong>4</strong></td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
<td align="center">8</td>
</tr>
<tr class="even">
<td align="left">9</td>
<td align="center">10</td>
<td align="center">11</td>
<td align="left">12</td>
<td align="center">13</td>
<td align="center">14</td>
<td align="center">15</td>
<td align="center">16</td>
</tr>
<tr class="odd">
<td align="left">17</td>
<td align="center">18</td>
<td align="center">19</td>
<td align="left">20</td>
<td align="center">21</td>
<td align="center">22</td>
<td align="center">23</td>
<td align="center">24</td>
</tr>
<tr class="even">
<td align="left">25</td>
<td align="center">26</td>
<td align="center">27</td>
<td align="left">28</td>
<td align="center">29</td>
<td align="center">30</td>
<td align="center">31</td>
<td align="center">32</td>
</tr>
<tr class="odd">
<td align="left">33</td>
<td align="center">34</td>
<td align="center">35</td>
<td align="left">36</td>
<td align="center">37</td>
<td align="center">38</td>
<td align="center">39</td>
<td align="center">40</td>
</tr>
<tr class="even">
<td align="left">41</td>
<td align="center">42</td>
<td align="center">43</td>
<td align="left">44</td>
<td align="center">45</td>
<td align="center">46</td>
<td align="center">47</td>
<td align="center">48</td>
</tr>
<tr class="odd">
<td align="left">49</td>
<td align="center">50</td>
<td align="center">51</td>
<td align="left">52</td>
<td align="center">53</td>
<td align="center">54</td>
<td align="center">55</td>
<td align="center">56</td>
</tr>
<tr class="even">
<td align="left">57</td>
<td align="center">58</td>
<td align="center">59</td>
<td align="left">60</td>
<td align="center">61</td>
<td align="center">62</td>
<td align="center">63</td>
<td align="center">64</td>
</tr>
</tbody>
</table>
</div><div id="马周游-题目大意-2" class="slide section level2">
<h1>1152 1153 马周游 题目大意</h1>
<table>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="left"><strong>4</strong></td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
<td align="center">8</td>
</tr>
<tr class="even">
<td align="left">9</td>
<td align="center">10</td>
<td align="center">11</td>
<td align="left">12</td>
<td align="center">13</td>
<td align="center">14</td>
<td align="center">15</td>
<td align="center">16</td>
</tr>
<tr class="odd">
<td align="left">17</td>
<td align="center">18</td>
<td align="center">19</td>
<td align="left">20</td>
<td align="center"><strong>21</strong></td>
<td align="center">22</td>
<td align="center">23</td>
<td align="center">24</td>
</tr>
<tr class="even">
<td align="left">25</td>
<td align="center">26</td>
<td align="center">27</td>
<td align="left">28</td>
<td align="center">29</td>
<td align="center">30</td>
<td align="center">31</td>
<td align="center">32</td>
</tr>
<tr class="odd">
<td align="left">33</td>
<td align="center">34</td>
<td align="center">35</td>
<td align="left">36</td>
<td align="center">37</td>
<td align="center">38</td>
<td align="center">39</td>
<td align="center">40</td>
</tr>
<tr class="even">
<td align="left">41</td>
<td align="center">42</td>
<td align="center">43</td>
<td align="left">44</td>
<td align="center">45</td>
<td align="center">46</td>
<td align="center">47</td>
<td align="center">48</td>
</tr>
<tr class="odd">
<td align="left">49</td>
<td align="center">50</td>
<td align="center">51</td>
<td align="left">52</td>
<td align="center">53</td>
<td align="center">54</td>
<td align="center">55</td>
<td align="center">56</td>
</tr>
<tr class="even">
<td align="left">57</td>
<td align="center">58</td>
<td align="center">59</td>
<td align="left">60</td>
<td align="center">61</td>
<td align="center">62</td>
<td align="center">63</td>
<td align="center">64</td>
</tr>
</tbody>
</table>
</div><div id="马周游-题目大意-3" class="slide section level2">
<h1>1152 1153 马周游 题目大意</h1>
<table>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="left"><strong>4</strong></td>
<td align="center">5</td>
<td align="left"><strong>6</strong></td>
<td align="center">7</td>
<td align="center">8</td>
</tr>
<tr class="even">
<td align="left">9</td>
<td align="center">10</td>
<td align="center">11</td>
<td align="left">12</td>
<td align="center">13</td>
<td align="left">14</td>
<td align="center">15</td>
<td align="center">16</td>
</tr>
<tr class="odd">
<td align="left">17</td>
<td align="center">18</td>
<td align="center">19</td>
<td align="left">20</td>
<td align="center"><strong>21</strong></td>
<td align="left">22</td>
<td align="center">23</td>
<td align="center">24</td>
</tr>
<tr class="even">
<td align="left">25</td>
<td align="center">26</td>
<td align="center">27</td>
<td align="left">28</td>
<td align="center">29</td>
<td align="left">30</td>
<td align="center">31</td>
<td align="center">32</td>
</tr>
<tr class="odd">
<td align="left">33</td>
<td align="center">34</td>
<td align="center">35</td>
<td align="left">36</td>
<td align="center">37</td>
<td align="left">38</td>
<td align="center">39</td>
<td align="center">40</td>
</tr>
<tr class="even">
<td align="left">41</td>
<td align="center">42</td>
<td align="center">43</td>
<td align="left">44</td>
<td align="center">45</td>
<td align="left">46</td>
<td align="center">47</td>
<td align="center">48</td>
</tr>
<tr class="odd">
<td align="left">49</td>
<td align="center">50</td>
<td align="center">51</td>
<td align="left">52</td>
<td align="center">53</td>
<td align="left">54</td>
<td align="center">55</td>
<td align="center">56</td>
</tr>
<tr class="even">
<td align="left">57</td>
<td align="center">58</td>
<td align="center">59</td>
<td align="left">60</td>
<td align="center">61</td>
<td align="left">62</td>
<td align="center">63</td>
<td align="center">64</td>
</tr>
</tbody>
</table>
</div><div id="马周游-解题思路" class="slide section level2">
<h1>1152 1153 马周游 解题思路</h1>
<ul class="incremental">
<li><p>深搜</p></li>
<li><p>枚举马能走的所有路径，直至找到一条完成周游的路径</p></li>
<li><p>回溯</p></li>
</ul>
</div><div id="马周游-代码" class="slide section level2">
<h1>1152 1153 马周游 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> Solve(<span class="dt">int</span> x, <span class="dt">int</span> depth) {
  route[depth] = x + <span class="dv">1</span>;
  <span class="kw">if</span> (depth == m * n - <span class="dv">1</span>) {
    print_route();
    <span class="kw">return</span> <span class="kw">true</span>;
  }
  visit[x] = <span class="kw">true</span>;

  <span class="co">//搜索对效率要求较高，建议将这里换成int children[8]以提高效率。</span>
  vector&lt;<span class="dt">int</span>&gt; children;

  get_children(x, &amp;children);
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; children.size(); ++i) {
    <span class="kw">if</span> (Solve(children[i], depth + <span class="dv">1</span>)) <span class="kw">return</span> <span class="kw">true</span>;
  }

  visit[x] = <span class="kw">false</span>;
  <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">void</span> get_children(<span class="dt">int</span> x, vector&lt;<span class="dt">int</span>&gt; *children) {
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; neighbors[x].size(); ++i) {
    <span class="dt">int</span> child = neighbors[x][i];
    <span class="kw">if</span> (!visit[child]) {
      children-&gt;push_back(child);
    }
  }
}</code></pre>
</div><div id="马周游-缺点" class="slide section level2">
<h1>1152 1153 马周游 缺点</h1>
<div class="incremental">
<p>程序过慢，只能勉强过1152</p>
</div>
<div class="incremental">
<p>优化：改变搜索顺序</p>
<p>先搜索可行格较少的格子</p>
<table>
<tbody>
<tr class="odd">
<td align="left">x</td>
<td align="center">.</td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr class="even">
<td align="left">x</td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">.</td>
<td align="center">.</td>
</tr>
<tr class="odd">
<td align="left">.</td>
<td align="center">x</td>
<td align="center">?(2)</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr class="even">
<td align="left"><strong>x</strong></td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">.</td>
<td align="center">.</td>
</tr>
<tr class="odd">
<td align="left">x</td>
<td align="center">.</td>
<td align="center">?(1)</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
</tbody>
</table>
</div>
</div><div id="马周游-代码-1" class="slide section level2">
<h1>1152 1153 马周游 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> cnt_size[<span class="dv">64</span>];

<span class="dt">bool</span> cmp(<span class="dt">int</span> x, <span class="dt">int</span> y) {
  <span class="kw">return</span> cnt_size[x] &lt; cnt_size[y];
}

<span class="dt">int</span> get_children_size(<span class="dt">int</span> x) {
  <span class="dt">int</span> size = <span class="dv">0</span>;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; neighbors[x].size(); ++i) {
    <span class="dt">int</span> child = neighbors[x][i];
    <span class="kw">if</span> (!visit[child]) {
      ++size;
    }
  }
  <span class="kw">return</span> size;
}

<span class="dt">void</span> get_children(<span class="dt">int</span> x, vector&lt;<span class="dt">int</span>&gt; *children) {
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; neighbors[x].size(); ++i) {
    <span class="dt">int</span> child = neighbors[x][i];
    <span class="kw">if</span> (!visit[child]) {
      children-&gt;push_back(child);
      cnt_size[child] = get_children_size(child);
    }
  }
  sort(children-&gt;begin(), children-&gt;end(), cmp);
}</code></pre>
</div><div id="马周游-解题报告" class="slide section level2">
<h1>1152 1153 马周游 解题报告</h1>
<ul class="incremental">
<li><p>可在解题报告中尝试其他搜索顺序或剪枝，对比其效果</p></li>
<li><p>通过加大数据范围，如扩展到9x9, 10x10，本地跑程序来对比不同算法的性能</p></li>
<li><p>可以思考构造性的算法</p></li>
</ul>
</div>
<div id="air-express" class="titleslide slide section level1"><h1>1093 Air Express</h1></div><div id="air-express-题目大意" class="slide section level2">
<h1>1093 Air Express 题目大意</h1>
<p>给出4个重量区间 &amp; 每个区间的单位重量运输价格</p>
<table>
<thead>
<tr class="header">
<th align="left">Package weight</th>
<th align="center">Cost per pound</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0 to 9 pounds</td>
<td align="center">$10</td>
</tr>
<tr class="even">
<td align="left">10 to 49 pounds</td>
<td align="center">$5</td>
</tr>
<tr class="odd">
<td align="left">50 to 99 pounds</td>
<td align="center">$3</td>
</tr>
<tr class="even">
<td align="left">100 pounds or more</td>
<td align="center">$2</td>
</tr>
</tbody>
</table>
<p>有一个背包需要运输，问往背包里面添加多少重量后可以让运费最低</p>
</div><div id="air-express-解题思路" class="slide section level2">
<h1>1093 Air Express 解题思路</h1>
<table>
<thead>
<tr class="header">
<th align="left">Package weight</th>
<th align="center">Cost per pound</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0 to 9 pounds</td>
<td align="center">$10</td>
</tr>
<tr class="even">
<td align="left">10 to 49 pounds</td>
<td align="center">$5</td>
</tr>
<tr class="odd">
<td align="left">50 to 99 pounds</td>
<td align="center">$3</td>
</tr>
<tr class="even">
<td align="left">100 pounds or more</td>
<td align="center">$2</td>
</tr>
</tbody>
</table>
<p>最小运输价格必定出现在：</p>
<ol class="incremental" style="list-style-type: decimal">
<li>不添加任何重量</li>
<li>添加重量后刚好到达某个区间的下界</li>
</ol>
</div><div id="air-express-代码" class="slide section level2">
<h1>1093 Air Express 代码</h1>
<div class="incremental">
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> cal(<span class="dt">int</span> weight) {
  <span class="dt">int</span> price = INF;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">4</span>; i++) {
    <span class="kw">if</span> (lower[i] &lt;= weight &amp;&amp; weight &lt;= upper[i]) {
      price = min(price, weigth * rate[i]);
    } <span class="kw">else</span> <span class="kw">if</span> (weight &lt; lower[i]) {
      price = min(price, lower[i] * rate[i]);
    }
  }
  <span class="kw">return</span> price;
}</code></pre>
</div>
<div class="incremental">
<p>修改这段代码让它输出需要添加的重量</p>
</div>
</div>
<div id="积木分发" class="titleslide slide section level1"><h1>1134 积木分发</h1></div><div id="积木分发-题目大意" class="slide section level2">
<h1>1134 积木分发 题目大意</h1>
<p>n个小伙伴，每个人手上有<span class="math">\(a_i\)</span>块积木，还需要<span class="math">\(b_i\)</span>块积木才能完成任务</p>
<p>The Pancakes手上有s块积木，她可以把她手中的积木都给某个人，等那个人完成任务后回收他手上的所有积木</p>
<p>问The Pancakes最后是否能回收完所有人的积木</p>
<p><span class="math">\(s \le 10^6, n \le 10^4, a, b \le 10^9\)</span></p>
</div><div id="积木分发-样例" class="slide section level2">
<h1>1134 积木分发 样例</h1>
<div class="incremental">
<p>第一个样例：</p>
<p>n = 2, s = 2</p>
<p>a = 1, b = 4</p>
<p>a = 2, b = 1</p>
<p>分给第二个人 -&gt; s = 4 -&gt; 再分给第一个人 -&gt; s = 5</p>
</div>
<div class="incremental">
<p>第二个样例：</p>
<p>n = 2, s = 2</p>
<p>a = 1, b = 4</p>
<p>a = 1, b = 1</p>
<p>分给第二个人 -&gt; s = 3 -&gt; 第一人仍然不够，失败</p>
</div>
</div><div id="积木分发-解题思路" class="slide section level2">
<h1>1134 积木分发 解题思路</h1>
<div class="incremental">
<p>应该先分给需求少的人，因为分完后The Pancakes手上的积木总是会变多的</p>
</div>
<div class="incremental">
<p>排序后贪心求解</p>
</div>
</div><div id="积木分发-代码" class="slide section level2">
<h1>1134 积木分发 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Node {
  <span class="dt">int</span> have, need;
};
<span class="dt">bool</span> <span class="kw">operator</span>&lt;(<span class="dt">const</span> Node&amp; x, <span class="dt">const</span> Node&amp; y) {
  <span class="kw">return</span> x.need &lt; y.need;
}
<span class="dt">bool</span> Solve() {
  sort(nodes, nodes + n);
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
    <span class="kw">if</span> (s &lt; nodes[i].need) <span class="kw">return</span> <span class="kw">false</span>;
    s += nodes[i].have;
  }
  <span class="kw">return</span> <span class="kw">true</span>;
}</code></pre>
</div>
<div id="国王的遗产" class="titleslide slide section level1"><h1>1140 国王的遗产</h1></div><div id="国王的遗产-题目大意" class="slide section level2">
<h1>1140 国王的遗产 题目大意</h1>
<p>一棵由n块金块组成的树</p>
<p>k个人按顺序轮流拿金块，每个人拿的时候选择树的一条边将其分割成两棵树</p>
<div id="king1">

</div>
</div><div id="国王的遗产-题目大意-1" class="slide section level2">
<h1>1140 国王的遗产 题目大意</h1>
<div id="king2">

</div>
<p>拿的那部分的金块数不能超过当前金块总数的一半</p>
<p>每个人都希望拿到尽量多的金块</p>
<p>如果有多种拿法，则拿最小金块编号最小的那一块</p>
</div><div id="国王的遗产-题目大意-2" class="slide section level2">
<h1>1140 国王的遗产 题目大意</h1>
<div id="king3">

</div>
<script src="lecture.js"></script>
<script>
graph_king = {
nodes: [
       {name: 1, color: "#66ccff"},
       {name: 2, color: "#66ccff"},
       {name: 3, color: "#66ccff"},
       {name: 4, color: "#66ccff"},
       {name: 5, color: "#66ccff"},
       {name: 6, color: "#66ccff"},
       ],
       edges: [
       {source: 0, target: 1},
       {source: 1, target: 2},
       {source: 2, target: 3},
       {source: 1, target: 4},
       {source: 2, target: 5}
       ]
};

var w = 500;
var h = 300;
var svg = d3.select("div#king1").append("svg")
.attr('viewBox', "0 0 " + w + " " + h)
.attr('preserveAspectRatio', "xMinYMin meet")
.attr('width', w).attr('height', h);
GraphKing.createNew(svg, w, h, graph_king);

graph_king = {
nodes: [
       {name: 1, color: "yellow"},
       {name: 2, color: "yellow"},
       {name: 3, color: "#66ccff"},
       {name: 4, color: "#66ccff"},
       {name: 5, color: "yellow"},
       {name: 6, color: "#66ccff"},
       ],
       edges: [
       {source: 0, target: 1},
       {source: 2, target: 3},
       {source: 1, target: 4},
       {source: 2, target: 5}
       ]
};

var svg = d3.select("div#king2").append("svg")
.attr('width', w).attr('height', h);
GraphKing.createNew(svg, w, h, graph_king);

graph_king = {
nodes: [
       {name: 1, color: "yellow"},
       {name: 2, color: "yellow"},
       {name: 3, color: "#66ccff"},
       {name: 4, color: "orange"},
       {name: 5, color: "yellow"},
       {name: 6, color: "#66ccff"},
       ],
       edges: [
       {source: 0, target: 1},
       {source: 1, target: 4},
       {source: 2, target: 5}
       ]
};

var svg = d3.select("div#king3").append("svg")
.attr('width', w).attr('height', h);
GraphKing.createNew(svg, w, h, graph_king);

</script>

</div><div id="国王的遗产-题目大意-3" class="slide section level2">
<h1>1140 国王的遗产 题目大意</h1>
<pre><code>6 3
1 2
2 3
3 4
2 5
3 6

3 1 2</code></pre>
<p><span class="math">\(n \le 30000, k \le 100\)</span></p>
</div><div id="国王的遗产-解题思路" class="slide section level2">
<h1>1140 国王的遗产 解题思路</h1>
<div class="incremental">
<p>按顺序做，枚举每一个人，检查切断每一条边所得到的两棵子树，计算其节点数和最小编号</p>
<p>如何得到这两棵子树？</p>
</div>
<div class="incremental">
<p>去掉边后做DFS</p>
<p>复杂度？</p>
</div>
<div class="incremental">
<p><span class="math">\(O(N^2 K)\)</span>, 枚举边 * DFS求大小 * K次，无法承受</p>
</div>
</div><div id="国王的遗产-解题思路-1" class="slide section level2">
<h1>1140 国王的遗产 解题思路</h1>
<p>转化成有根树，只需要做一次DFS</p>
<div id="king4">

</div>
<script>
graph_king = {
nodes: [
       {name: "1 [5]", color: "#66ccff"},
       {name: "2 [4]", color: "#66ccff"},
       {name: "3 [2]", color: "#66ccff"},
       {name: "4 [0]", color: "#66ccff"},
       {name: "5 [0]", color: "#66ccff"},
       {name: "6 [0]", color: "#66ccff"},
       ],
       edges: [
       {source: 0, target: 1},
       {source: 1, target: 2},
       {source: 2, target: 3},
       {source: 1, target: 4},
       {source: 2, target: 5}
       ]
};

var w = 500;
var h = 300;
var svg = d3.select("div#king4").append("svg")
.attr('viewBox', "0 0 " + w + " " + h)
.attr('preserveAspectRatio', "xMinYMin meet")
.attr('width', w).attr('height', h);
GraphKing.createNew(svg, w, h, graph_king);
</script>


</div><div id="国王的遗产-代码" class="slide section level2">
<h1>1140 国王的遗产 代码</h1>
<p>记录子树的大小，删除的边的两个端点，子树中的最小编号</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> SubTree {
  <span class="dt">int</span> num_nodes;
  <span class="dt">int</span> insider, outsider;
  <span class="dt">int</span> min_id;
};</code></pre>
<p>用vector<int>来保存树的边</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span> kMaxN = <span class="dv">31000</span>;
vector&lt;<span class="dt">int</span>&gt; G[kMaxN];
SubTree subtree[kMaxN];</code></pre>
</div><div id="国王的遗产-代码-1" class="slide section level2">
<h1>1140 国王的遗产 代码</h1>
<p>不同子树之间的比较：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> <span class="kw">operator</span>&lt;(<span class="dt">const</span> SubTree&amp; a, <span class="dt">const</span> SubTree&amp; b) {
  <span class="kw">if</span> (a.num_nodes != b.num_nodes) {
    <span class="kw">return</span> a.num_nodes &gt; b.num_nodes;
  }
  <span class="kw">return</span> a.min_id &lt; b.min_id;
}</code></pre>
<p>主过程：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;<span class="dt">int</span>&gt; ans;
pivot = <span class="dv">0</span>;
total = n;
<span class="kw">for</span> (<span class="dt">int</span> ichild = <span class="dv">0</span>; ichild &lt; num_children - <span class="dv">1</span>; ++ichild) {
  pivot = dfs_find_min(pivot, -<span class="dv">1</span>);

  best.num_nodes = -<span class="dv">1</span>;
  dfs(pivot, -<span class="dv">1</span>);
  ans.push_back(best.num_nodes);

  <span class="co">// Remove edge best.insider &lt;-&gt; best.outsider</span>

  total -= best.num_nodes;
  pivot = best.outsider;
}</code></pre>
</div><div id="国王的遗产-代码-2" class="slide section level2">
<h1>1140 国王的遗产 代码</h1>
<p>找出树中的最小编号，从该编号开始DFS</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> dfs_find_min(<span class="dt">int</span> x, <span class="dt">int</span> parent) {
  <span class="dt">int</span> min_id = x;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; G[x].size(); ++i) {
    <span class="dt">int</span> child = G[x][i];
    <span class="kw">if</span> (child == parent) <span class="kw">continue</span>;
    min_id = min(min_id, dfs_find_min(child, x));
  }
  <span class="kw">return</span> min_id;
}</code></pre>
</div><div id="国王的遗产-代码-3" class="slide section level2">
<h1>1140 国王的遗产 代码</h1>
<p>主DFS过程</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> total;
<span class="dt">int</span> pivot;
SubTree best;
<span class="dt">void</span> dfs(<span class="dt">int</span> x, <span class="dt">int</span> parent) {
  subtree[x].num_nodes = <span class="dv">1</span>;
  subtree[x].min_id = x;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; G[x].size(); ++i) {
    <span class="dt">int</span> child = G[x][i];
    <span class="kw">if</span> (child == parent) <span class="kw">continue</span>;
    dfs(child, x);
    subtree[x].num_nodes += subtree[child].num_nodes;
    subtree[x].min_id = min(subtree[x].min_id, subtree[child].min_id);
  }
  <span class="kw">if</span> (x != pivot) {
    subtree[x].outsider = parent;
    subtree[x].insider = x;
    <span class="kw">if</span> (subtree[x].num_nodes &lt;= total / <span class="dv">2</span>) {
      best = min(best, subtree[x]);
    }
    SubTree subtree2;
    subtree2.num_nodes = total - subtree[x].num_nodes;
    subtree2.min_id = pivot;
    subtree2.insider = parent;
    subtree2.outsider = x;
    <span class="kw">if</span> (subtree2.num_nodes &lt;= total / <span class="dv">2</span>) {
      best = min(best, subtree2);
    }
  }
}</code></pre>
</div>
<div id="shopaholic" class="titleslide slide section level1"><h1>1438 Shopaholic</h1></div><div id="shopaholic-题目大意" class="slide section level2">
<h1>1438 Shopaholic 题目大意</h1>
<p>买东西 每买三件东西 最便宜的一件免费</p>
<p>给出n个需要买的东西</p>
<p>问最多免费多少？</p>
<p><span class="math">\(n \le 20000, price \le 20000\)</span></p>
</div><div id="shopaholic-样例" class="slide section level2">
<h1>1438 Shopaholic 样例</h1>
<p>6</p>
<p>400 100 200 350 300 250</p>
<p>(400 350 300) (250 200 100) =&gt; 400</p>
</div><div id="shopaholic-解题思路" class="slide section level2">
<h1>1438 Shopaholic 解题思路</h1>
<div class="incremental">
<p>尽量使价格高的东西免费</p>
</div>
<div class="incremental">
<p>按价格从高到低排序，每三件取一件免费</p>
</div>
<div class="incremental">
<p>严格证明？考虑最便宜的商品，必须找两个和它配对</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">sort(price, price + n, greater&lt;<span class="dt">int</span>&gt;());
<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">2</span>; i &lt; n; i += <span class="dv">3</span>) {
  saved += price[i];
}</code></pre>
</div>
</div>
<div id="hanoi-tower-sequence" class="titleslide slide section level1"><h1>1028 Hanoi Tower Sequence</h1></div><div id="hanoi-tower-sequence-题目大意" class="slide section level2">
<h1>1028 Hanoi Tower Sequence 题目大意</h1>
<div class="incremental">
<p>汉诺塔：三个柱子和大小两两不同的盘子放在一个柱子上</p>
<p>目的：将这些盘子移动到另外一个柱子上</p>
<p>规则：每次只能移动最顶端的一个盘子，每次移动后较小的盘子必须放在较大的盘子上面</p>
</div>
<div class="incremental">
<p>现在给出步数p，问第p步移动的盘子的大小</p>
<p><span class="math">\(p \le 10^{100}\)</span></p>
</div>
</div><div id="hanoi-tower-sequence-题目大意-1" class="slide section level2">
<h1>1028 Hanoi Tower Sequence 题目大意</h1>
<div class="figure">
<img src="1028.png" alt="规则" /><p class="caption">规则</p>
</div>
<ol class="incremental" style="list-style-type: decimal">
<li>把前n - 1个盘子移到第二根柱子上</li>
<li>把第n个盘子移到第三根柱子上</li>
<li>把前n - 1个盘子移到第三根柱子上</li>
</ol>
</div><div id="hanoi-tower-sequence-解题思路" class="slide section level2">
<h1>1028 Hanoi Tower Sequence 解题思路</h1>
<div class="incremental">
<p>先递归求解总步数</p>
<p>设移动k个盘子需要f(k)步，则有：</p>
<p>f(k) = f(k - 1) + 1 + f(k - 1)</p>
<p>f(1) = 1</p>
<p>所以：</p>
</div>
<div class="incremental">
<p><span class="math">\(f(k) = 2^k - 1\)</span></p>
</div>
</div><div id="hanoi-tower-sequence-解题思路-1" class="slide section level2">
<h1>1028 Hanoi Tower Sequence 解题思路</h1>
<p>发现：</p>
<p>第<span class="math">\(2^k\)</span>步移动的是第k + 1个盘子</p>
</div><div id="hanoi-tower-sequence-解题思路-2" class="slide section level2">
<h1>1028 Hanoi Tower Sequence 解题思路</h1>
<div class="incremental">
<p>找规律</p>
<pre><code>1
1 2 1
1 2 1 3 1 2 1
1 2 1 3 1 2 1 4 1 2 1 3 1 2 1
1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 </code></pre>
<p>具有自相似的特性</p>
</div>
<div class="incremental">
<pre><code>0001 =&gt; 0
0010 =&gt; 1
0011 =&gt; 0
0100 =&gt; 2
0101 =&gt; 0
0110 =&gt; 1
0111 =&gt; 0
1000 =&gt; 3
1001 =&gt; 0
1010 =&gt; 1
1011 =&gt; 0
1100 =&gt; 2
1101 =&gt; 0
1110 =&gt; 1
1111 =&gt; 0</code></pre>
</div>
</div><div id="hanoi-tower-sequence-解题思路-3" class="slide section level2">
<h1>1028 Hanoi Tower Sequence 解题思路</h1>
<p>答案为把p表示成2进制数，最后有多少个零，再加1</p>
<p>假设x是读进来的数字，x[n - 1]是最低位：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> ans = <span class="dv">1</span>;
<span class="kw">while</span> (x[n - <span class="dv">1</span>] % <span class="dv">2</span> == <span class="dv">0</span>) {
  ++ans;

  <span class="co">// 除2</span>
  <span class="dt">int</span> remain = <span class="dv">0</span>;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
    remain = remain * <span class="dv">10</span> + x[i];
    x[i] = remain / <span class="dv">2</span>;
    remain %= <span class="dv">2</span>;
  }
  assert(remain == <span class="dv">0</span>);
}</code></pre>
</div>
<div id="rabbit" class="titleslide slide section level1"><h1>1029 Rabbit</h1></div><div id="rabbit-题目大意" class="slide section level2">
<h1>1029 Rabbit 题目大意</h1>
<p>开始有一对成年兔子</p>
<p>每对成年兔子每个月产生一对小兔子</p>
<p>每只小兔子经过m个月变成成年兔子</p>
<p>问经过d个月后有多少兔子</p>
<p><span class="math">\(1 \le m \le 10, 1 \le d \le 100\)</span></p>
</div><div id="rabbit-题目大意-1" class="slide section level2">
<h1>1029 Rabbit 题目大意</h1>
<p>m = 2时是经典的Fibonacci问题</p>
</div><div id="rabbit-解题思路" class="slide section level2">
<h1>1029 Rabbit 解题思路</h1>
<div class="incremental">
<p>每个月的兔子数量 = 上个月兔子数量 + 这个月出生的小兔子数量</p>
</div>
<div class="incremental">
<p>小兔子由大兔子生育得到，这些大兔子在m个月前就必须存在了</p>
<p>每个月的兔子数量 = 上个月兔子数量 + m个月前的兔子数量</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">dp[n] = dp[n - <span class="dv">1</span>] + dp[n - m]</code></pre>
</div>
</div><div id="rabbit-代码" class="slide section level2">
<h1>1029 Rabbit 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> BigInteger {
  <span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> kMaxLen = <span class="dv">100</span>;
  <span class="dt">int</span> x[kMaxLen];
  BigInteger(<span class="dt">int</span> a = <span class="dv">0</span>) {
    memset(x, <span class="dv">0</span>, <span class="kw">sizeof</span> (x));
    x[<span class="dv">0</span>] = a;
  }
};

<span class="co">// 效率较低，只做演示用！</span>
BigInteger <span class="kw">operator</span>+(<span class="dt">const</span> BigInteger&amp; a, <span class="dt">const</span> BigInteger&amp; b) {
  BigInteger c;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; kMaxLen - <span class="dv">1</span>; ++i) {
    c.x[i] += a.x[i] + b.x[i];
    c.x[i + <span class="dv">1</span>] += c.x[i] / <span class="dv">10</span>;
    c.x[i] %= <span class="dv">10</span>;
  }
  <span class="kw">return</span> c;
}

dp[<span class="dv">0</span>] = BigInteger(<span class="dv">1</span>);
<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= d; ++i) {
  <span class="kw">if</span> (i &lt; m) {
    a[i] = a[i - <span class="dv">1</span>] + BigInteger(<span class="dv">1</span>);
  } <span class="kw">else</span> {
    a[i] = a[i - <span class="dv">1</span>] + a[i - m];
  }
}</code></pre>
</div>
<div id="ab" class="titleslide slide section level1"><h1>1381 a*b</h1></div><div id="ab-题目大意" class="slide section level2">
<h1>1381 a*b 题目大意</h1>
<p>给两个整数a和b，求<span class="math">\(a \times b\)</span></p>
<p><span class="math">\(0 \le a \le 10^{100}, 0 \le b \le 10000\)</span></p>
<p>a, b都有可能是0</p>
</div><div id="ab-解题思路" class="slide section level2">
<h1>1381 a*b 解题思路</h1>
<p>高精度乘法，模拟竖式乘法</p>
<p>输出时注意前导0和0的情况</p>
</div><div id="ab-代码" class="slide section level2">
<h1>1381 a*b 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> BigInteger {
  <span class="dt">static</span> <span class="dt">const</span> <span class="dt">int</span> kMaxLen = <span class="dv">120</span>;
  <span class="dt">int</span> x[kMaxLen];
  BigInteger(<span class="dt">int</span> a = <span class="dv">0</span>) {
    memset(x, <span class="dv">0</span>, <span class="kw">sizeof</span> (x));
    x[<span class="dv">0</span>] = a;
  }
  BigInteger <span class="kw">operator</span>*(<span class="dt">int</span> b) <span class="dt">const</span> {
    BigInteger res(<span class="dv">0</span>);
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; kMaxLen; i++) {
      res.x[i] += x[i] * b;
      res.x[i + <span class="dv">1</span>] += c.x[i] / <span class="dv">10</span>;
      res.x[i] %= <span class="dv">10</span>;
    }
    <span class="kw">return</span> res;
  }
};</code></pre>
<p>以此为基础，可自行练习大整数乘大整数的程序。</p>
<p>另外，这两个大整数程序都以10为进位， 实际使用时可以用10000为进位数，把4个数字压在一个数组中，可以明显提高程序效率。</p>
</div>
<div id="stacking-cylinders" class="titleslide slide section level1"><h1>1206 1012 Stacking Cylinders</h1></div><div id="stacking-cylinders-题目大意" class="slide section level2">
<h1>1206 1012 Stacking Cylinders 题目大意</h1>
<p>给出最底层的n个圆柱的位置，求最顶层的圆柱的位置</p>
<p>圆柱半径都为1</p>
<p><span class="math">\(1 \le n \le 10\)</span></p>
<div class="figure">
<img src="1206.jpg" alt="如图" /><p class="caption">如图</p>
</div>
</div><div id="stacking-cylinders-解题思路" class="slide section level2">
<h1>1206 1012 Stacking Cylinders 解题思路</h1>
<p>已知两个圆的圆心坐标，求放在这两个圆上的圆的圆心坐标</p>
<p>向量 勾股定理</p>
</div><div id="stacking-cylinders-complex库" class="slide section level2">
<h1>1206 1012 Stacking Cylinders complex库</h1>
<p>STL中的复数库可以简化代码</p>
<p>复数的旋转：<span class="math">\(a \times e^{i \theta}\)</span></p>
<p>两个点之间的距离：<span class="math">\(\|a - b\|\)</span></p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">complex&lt;<span class="dt">double</span>&gt; a, b;
b = a * exp(complex&lt;<span class="dt">double</span>&gt;(<span class="dv">0</span>, t));  <span class="co">//旋转角度为t</span>
b = a * complex&lt;<span class="dt">double</span>&gt;(<span class="dv">0</span>, <span class="dv">1</span>);  <span class="co">//旋转90度</span>
sqrt(norm(a - b));  <span class="co">// 两点之间的距离</span>
abs(a - b);  <span class="co">// 或者</span>
a.real();  <span class="co">// x坐标</span>
a.imag();  <span class="co">// y坐标</span></code></pre>
</div><div id="stacking-cylinders-代码" class="slide section level2">
<h1>1206 1012 Stacking Cylinders 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> complex&lt;<span class="dt">double</span>&gt; Point;

<span class="dt">bool</span> cmp(<span class="dt">const</span> Point&amp; a, <span class="dt">const</span> Point&amp; b) {
  <span class="kw">return</span> a.real() &lt; b.real();
}

Point Calculate(<span class="dt">const</span> Point&amp; a, <span class="dt">const</span> Point&amp; b) {
  Point mid = (a + b) / Point(<span class="dv">2</span>, <span class="dv">0</span>);
  Point height = (b - mid) * Point(<span class="dv">0</span>, <span class="dv">1</span>);
  <span class="dt">double</span> len = sqrt(<span class="dv">4</span> - norm(a - mid));
  height = height / abs(height) * len;
  <span class="kw">return</span> mid + height;
}

sort(points, points + n, cmp);
<span class="kw">for</span> (<span class="dt">int</span> len = n - <span class="dv">1</span>; len &gt;= <span class="dv">1</span>; --len) {
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; len; ++i) {
    points[i] = Calculate(points[i], points[i + <span class="dv">1</span>]);
  }
}</code></pre>
</div>
<div id="queens-knights-and-pawns" class="titleslide slide section level1"><h1>1172 Queens, Knights and Pawns</h1></div><div id="queens-knights-and-pawns-题目大意" class="slide section level2">
<h1>1172 Queens, Knights and Pawns 题目大意</h1>
<p>给一个棋盘，若干后、马和兵的位置</p>
<p>求棋盘上有多个没被占领的格子不会受到后也不会受到马的攻击</p>
<p>棋盘大小<span class="math">\(1000 \times 1000\)</span>，每种棋子最多100个</p>
</div><div id="queens-knights-and-pawns-解题思路" class="slide section level2">
<h1>1172 Queens, Knights and Pawns 解题思路</h1>
<p>用二维数组表示一个棋盘</p>
<p>标记每个棋子的位置</p>
<p>再标记每个棋子能攻击的位置</p>
<p>最后计算有多少个位置不会被攻击</p>
</div><div id="queens-knights-and-pawns-代码" class="slide section level2">
<h1>1172 Queens, Knights and Pawns 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">enum</span> GridState {
  empty,
  occupied,
  attacked
};

<span class="dt">const</span> <span class="dt">int</span> kMaxN = <span class="dv">1024</span>;
GridState grid[kMaxN][kMaxN];

<span class="dt">void</span> occupy(vector&lt;Point&gt; v) {
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; v.size(); i++) {
    grid[v[i].x][v[i].y]] = occupied;
  }
}

<span class="dt">bool</span> in_board_and_unoccupied(Point p) {
  <span class="kw">if</span> (<span class="dv">1</span> &lt;= p.x &amp;&amp; p.x &lt;= num_row) {
    <span class="kw">if</span> (<span class="dv">1</span> &lt;= p.y &amp;&amp; p.y &lt;= num_col) {
      <span class="kw">return</span> grid[p.x][p.y]!=occupied;
    }
  }
  <span class="kw">return</span> <span class="kw">false</span>;
}</code></pre>
</div><div id="queens-knights-and-pawns-代码-1" class="slide section level2">
<h1>1172 Queens, Knights and Pawns 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="dt">int</span> dKnight[<span class="dv">8</span>][<span class="dv">2</span>] = {{<span class="dv">1</span>,<span class="dv">2</span>},{<span class="dv">1</span>,-<span class="dv">2</span>},{<span class="dv">2</span>,-<span class="dv">1</span>},{-<span class="dv">2</span>,-<span class="dv">1</span>},{-<span class="dv">1</span>,-<span class="dv">2</span>},{-<span class="dv">1</span>,<span class="dv">2</span>},{-<span class="dv">2</span>,<span class="dv">1</span>},{<span class="dv">2</span>,<span class="dv">1</span>}};
<span class="dt">int</span> dQueen[<span class="dv">8</span>][<span class="dv">2</span>] = {{<span class="dv">1</span>,<span class="dv">0</span>},{<span class="dv">1</span>,-<span class="dv">1</span>},{<span class="dv">0</span>,-<span class="dv">1</span>},{-<span class="dv">1</span>,-<span class="dv">1</span>},{-<span class="dv">1</span>,<span class="dv">0</span>},{-<span class="dv">1</span>,<span class="dv">1</span>},{<span class="dv">0</span>,<span class="dv">1</span>},{<span class="dv">1</span>,<span class="dv">1</span>}};

<span class="dt">void</span> KnightAttack(vector&lt;Point&gt; points) {
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; points.size(); i++) {
    <span class="kw">for</span> (<span class="dt">int</span> dir = <span class="dv">0</span>; dir &lt; <span class="dv">8</span>; dir++) {
      Point newp(points[i].x + dKnight[dir][<span class="dv">0</span>], points[i].y + dKnight[dir][<span class="dv">1</span>]);
      <span class="kw">if</span> (in_board_and_unoccupied(newp)) {
        grid[newp.x][newp.y] = attacked;
      }
    }
  }
}

<span class="dt">void</span> QueenAttack(vector&lt;Point&gt; points) {
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; points.size(); i++) {
    <span class="kw">for</span> (<span class="dt">int</span> dir = <span class="dv">0</span>; dir &lt; <span class="dv">8</span>; dir++) {
      Point newp(points[i].x + dQueen[dir][<span class="dv">0</span>], points[i].y + dQueen[dir][<span class="dv">1</span>]);
      <span class="kw">while</span> (in_board_and_unoccupied(newp)) {
        grid[newp.x][newp.y] = attacked;
        newp(newp.x + dQueen[dir][<span class="dv">0</span>], newp + dQueen[dir][<span class="dv">1</span>]);
      }
    }
  }
}</code></pre>
</div><div id="queens-knights-and-pawns-代码-2" class="slide section level2">
<h1>1172 Queens, Knights and Pawns 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp">memset(grid, <span class="dv">0</span>, <span class="kw">sizeof</span>(grid));
occupy(queen);
occupy(knight);
occupy(pawn);

KnightAttack(knight);
QueenAttack(queen);

<span class="dt">int</span> ans = <span class="dv">0</span>;
<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= num_row; i++) {
  <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= num_col; j++) {
    <span class="kw">if</span> (grid[i][j] == empty) {
      ans++;
    }
  }
}</code></pre>
</div>
<div id="forest" class="titleslide slide section level1"><h1>1034 Forest</h1></div><div id="forest-题目大意" class="slide section level2">
<h1>1034 Forest 题目大意</h1>
<p>n个节点</p>
<p>m条有向边</p>
<p>判断是否组成森林，如果是，求出它的最大深度和最大宽度</p>
<p><span class="math">\(n, m \le 100\)</span></p>
</div><div id="forest-解题思路" class="slide section level2">
<h1>1034 Forest 解题思路</h1>
<div class="incremental">
<p>有根树，边的方向已经确定</p>
</div>
<div class="incremental">
<p>判断是否为森林：</p>
<ul class="incremental">
<li>没有一个节点的入度超过1</li>
<li>计算深度值时没有出现矛盾</li>
<li>没有环</li>
</ul>
<p>具体做法：</p>
<p>入度为0的点都做DFS，为每个点计算深度，判断最后是否所有的点都被访问到</p>
</div>
</div><div id="forest-代码" class="slide section level2">
<h1>1034 Forest 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span> kMaxN = <span class="dv">128</span>;
vector&lt;<span class="dt">int</span>&gt; G[kMaxN];
<span class="dt">int</span> depth[kMaxN];  <span class="co">// -1: invalid</span>
<span class="dt">int</span> count_depth[kMaxN];
<span class="dt">int</span> indegree[kMaxN];

<span class="dt">bool</span> dfs(<span class="dt">int</span> x, <span class="dt">int</span> parent, <span class="dt">int</span> d) {
  depth[x] = d;
  ++count_depth[d];
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; G[x].size(); ++i) {
    <span class="dt">int</span> child = G[x][i];
    <span class="kw">if</span> (child == parent) <span class="kw">continue</span>;
    <span class="kw">if</span> (depth[child] != -<span class="dv">1</span>) <span class="kw">return</span> <span class="kw">false</span>;
    <span class="kw">if</span> (!dfs(child, x, d + <span class="dv">1</span>)) {
      <span class="kw">return</span> <span class="kw">false</span>;
    }
  }
  <span class="kw">return</span> <span class="kw">true</span>;
}</code></pre>
<pre class="sourceCode cpp"><code class="sourceCode cpp">memset(depth, -<span class="dv">1</span>, <span class="kw">sizeof</span> (depth));  <span class="co">// only the value -1, 0 can be memseted</span>
memset(count_depth, <span class="dv">0</span>, <span class="kw">sizeof</span> (count_depth));
<span class="dt">bool</span> is_forest = <span class="kw">true</span>;
<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
  <span class="kw">if</span> (indegree[i] == <span class="dv">0</span>) {
    <span class="kw">if</span> (!dfs(i, -<span class="dv">1</span>, <span class="dv">0</span>)) {
      is_forest = <span class="kw">false</span>;
      <span class="kw">break</span>;
    }
  } <span class="kw">else</span> <span class="kw">if</span> (indegree[i] != <span class="dv">1</span>) {
    is_forest = <span class="kw">false</span>;
    <span class="kw">break</span>;
  }
}
<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) <span class="kw">if</span> (depth[i] &lt; <span class="dv">0</span>) {
  is_forest = <span class="kw">false</span>;
}</code></pre>
</div>
<div id="up-the-stairs" class="titleslide slide section level1"><h1>1193 Up the Stairs</h1></div><div id="up-the-stairs-题目大意" class="slide section level2">
<h1>1193 Up the Stairs 题目大意</h1>
<div class="incremental">
<p>N个人在F层之间搬箱子</p>
<p>开始时每个人都位于某一层上，要么手头拿着箱子，要么没有</p>
<p>拿着箱子的人会往上走，没拿的会往下走</p>
<p>当两个人相遇时，拿着箱子的人会把箱子交给没有箱子的人，互换方向继续走</p>
<p>走到F层的人把箱子放下，走到0层的人把箱子拿起来</p>
<p>初始时，0层有B个箱子，问多少时间后，所有箱子都在F层</p>
</div>
<div class="incremental">
<p>| 0, B boxes | 1 | 2 | ... | <span class="math">\(\blacksquare \rightarrow\)</span> | ... | <span class="math">\(\leftarrow \Box\)</span> | ... | F-1 | F |</p>
<p>| 0, B boxes | 1 | 2 | ... | <span class="math">\(\leftarrow \Box\)</span> | ... | <span class="math">\(\blacksquare \rightarrow\)</span> | ... | F-1 | F |</p>
<p><span class="math">\(1 \le N, F \le 1000, 1 \le B \le 10^6\)</span></p>
</div>
</div><div id="up-the-stairs-解题思路" class="slide section level2">
<h1>1193 Up the Stairs 解题思路</h1>
<div class="incremental">
<p>两个人交换箱子互换方向，相当于互相穿过没有交换</p>
<p>经过2F时间后，所有人的状态是没有改变的</p>
</div>
<div class="incremental">
<p>很容易计算经过t时间后，每个人搬了多少箱子</p>
</div>
</div><div id="up-the-stairs-代码" class="slide section level2">
<h1>1193 Up the Stairs 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> n, num_floor, base;
<span class="dt">bool</span> can_finish(<span class="dt">int</span> t) {
  <span class="dt">int</span> moved = <span class="dv">0</span>;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
    <span class="dt">int</span> time2 = t;
    <span class="kw">if</span> (person[i].state == <span class="dv">0</span>) {
      time2 += num_floor - person[i].x;
    } <span class="kw">else</span> {
      --moved;
      time2 += num_floor + person[i].x;
    }
    moved += time2 / (<span class="dv">2</span> * num_floor);
  }
  <span class="kw">return</span> moved &gt;= base;
}</code></pre>
</div><div id="up-the-stairs-解题思路-1" class="slide section level2">
<h1>1193 Up the Stairs 解题思路</h1>
<p>反过来如何计算？</p>
<p>二分答案，设经过t时间后可以完成任务</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> lo = <span class="dv">0</span>, hi = <span class="dv">2</span> * base * num_floor;
<span class="kw">while</span> (lo != hi) {
  <span class="dt">int</span> mid = lo + (hi - lo) / <span class="dv">2</span>;
  <span class="kw">if</span> (can_finish(mid)) {
    hi = mid;
  } <span class="kw">else</span> {
    lo = mid + <span class="dv">1</span>;
  }
}
printf(<span class="st">&quot;%d</span><span class="ch">\n</span><span class="st">&quot;</span>, lo);</code></pre>
</div>
<div id="i-conduit" class="titleslide slide section level1"><h1>1004 I Conduit!</h1></div><div id="i-conduit-题目大意" class="slide section level2">
<h1>1004 I Conduit! 题目大意</h1>
<p>二维坐标平面上有n条边，如果两条边有重叠部分，则可以合并成一条边</p>
<p>问合并后的边的数量</p>
<p><span class="math">\(n \le 10^4\)</span> 坐标范围 [0.0, 1000.0]</p>
</div><div id="i-conduit-解题思路" class="slide section level2">
<h1>1004 I Conduit! 解题思路</h1>
<ul class="incremental">
<li>对线段按斜率进行排序，方向相同，所在直线也相同</li>
<li>合并线段，区间合并问题</li>
</ul>
</div><div id="i-conduit-解法1直线点斜式排序" class="slide section level2">
<h1>1004 I Conduit! 解法1：直线点斜式排序</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Line {
  <span class="dt">double</span> k, b, pstart, pend;
  Line toline (<span class="dt">double</span> x1, <span class="dt">double</span> y1, <span class="dt">double</span> x2, <span class="dt">double</span> y2) {
    <span class="kw">if</span> (dcmp(x1, x2) == <span class="dv">0</span>) {
      k = INF;
      b = x1;
      pstart = min(y1, y2);
      pend = max(y1, y2);
    } <span class="kw">else</span> {
      k = (y2 - y1) / (x2 - x1);
      b = y1 - k * x1;
      pstart = min(x1, x2);
      pend = max(x1, x2);
    }
  }
};</code></pre>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">double</span> INF = <span class="fl">1e+15</span>;
<span class="dt">const</span> <span class="dt">double</span> EPS = <span class="fl">1e-7</span>;
<span class="dt">int</span> dcmp(<span class="dt">double</span> x, <span class="dt">double</span> y) {
    <span class="kw">if</span> (x - y &lt; -EPS) <span class="kw">return</span> -<span class="dv">1</span>;
    <span class="kw">if</span> (x - y &gt; EPS) <span class="kw">return</span> <span class="dv">1</span> ;
    <span class="kw">return</span> <span class="dv">0</span>;
}
<span class="dt">bool</span> line_cmp (<span class="dt">const</span> Line&amp; x, <span class="dt">const</span> Line&amp; y) {
    <span class="kw">if</span> (dcmp(x.k, y.k) != <span class="dv">0</span>) <span class="kw">return</span> dcmp(x.k, y.k) &lt; <span class="dv">0</span>;
    <span class="kw">if</span> (dcmp(x.b, y.b) != <span class="dv">0</span>) <span class="kw">return</span> dcmp(x.b, y.b) &lt; <span class="dv">0</span>;
    <span class="kw">return</span> dcmp(x.pstart, y.pstart) &lt; <span class="dv">0</span>;
}</code></pre>
</div><div id="i-conduit-解法2利用叉积判断方向来排序" class="slide section level2">
<h1>1004 I Conduit! 解法2：利用叉积判断方向来排序</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> complex&lt;int64&gt; Point;
<span class="ot">#define X real()</span>
<span class="ot">#define Y imag()</span>
int64 cross(<span class="dt">const</span> Point&amp; a, <span class="dt">const</span> Point&amp; b) {
  <span class="kw">return</span> imag(conj(a) * b);
}</code></pre>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Line {
  Point s, t, direction;
  <span class="dt">void</span> scan() {
    scan_point(&amp;s);
    scan_point(&amp;t);
    <span class="kw">if</span> (s.Y &gt; t.Y) {
      swap(s, t);
    }<span class="kw">else</span> <span class="kw">if</span> (s.Y == t.Y &amp;&amp; s.X &gt; t.X) {
      swap(s, t);
    }
    direction = t - s;
  }
  <span class="dt">int</span> get_min() <span class="dt">const</span> {
    <span class="kw">if</span> (s.X == t.X) <span class="kw">return</span> min(s.Y, t.Y);
    <span class="kw">return</span> min(s.X, t.X);
  }
  <span class="dt">int</span> get_max() <span class="dt">const</span> {
    <span class="kw">if</span> (s.X == t.X) <span class="kw">return</span> max(s.Y, t.Y);
    <span class="kw">return</span> max(s.X, t.X);
  }
};
<span class="dt">bool</span> <span class="kw">operator</span>&lt;(<span class="dt">const</span> Line&amp; a, <span class="dt">const</span> Line&amp; b) {
  int64 cross_value = cross(a.direction, b.direction);
  <span class="kw">if</span> (cross_value != <span class="dv">0</span>) <span class="kw">return</span> cross_value &lt; <span class="dv">0</span>;
  int64 cross_value2 = cross(a.s - b.s, a.t - b.s);
  <span class="kw">if</span> (cross_value2 != <span class="dv">0</span>) <span class="kw">return</span> cross_value2 &lt; <span class="dv">0</span>;
  <span class="kw">if</span> (a.get_min() != b.get_min()) <span class="kw">return</span> a.get_min() &lt; b.get_min();
  <span class="kw">return</span> a.get_max() &lt; b.get_max();
}</code></pre>
</div><div id="i-conduit-区间合并" class="slide section level2">
<h1>1004 I Conduit! 区间合并</h1>
<pre><code>sort(lines, lines + n);
int last = -1;
int cnt = 0;
for (int i = 0; i &lt; n; ++i) {
  if (i &gt; 0 &amp;&amp; cross(lines[i].direction, lines[i - 1].direction) == 0
      &amp;&amp; cross(lines[i].s - lines[i - 1].s, lines[i].direction) == 0) {
    if (lines[i].get_min() &gt; last) {
      ++cnt;
      last = lines[i].get_max();
    } else {
      last = max(last, lines[i].get_max());
    }
  } else {
    ++cnt;
    last = lines[i].get_max();
  }
}</code></pre>
</div>
<div id="rate-of-return" class="titleslide slide section level1"><h1>1017 Rate of Return</h1></div><div id="rate-of-return-题目大意" class="slide section level2">
<h1>1017 Rate of Return 题目大意</h1>
<p>Jill在某些月份会进行投资，这些投资额在每个月都会带来一定的利润</p>
<p>现在给出Jill某个月份结束后的本金和利润之和，求利润率</p>
<pre><code>2
1 100.00
3 100.00
4 210.00</code></pre>
<p>例如，1月份和3月份分别投资100，4月底得到210，设利润率为x，则有方程：</p>
<p><span class="math">\(100 (1+x)^4 + 100 (1+x)^2 = 210\)</span></p>
<p>解得：</p>
<p><span class="math">\(x = 0.01635\)</span></p>
</div><div id="rate-of-return-解题思路" class="slide section level2">
<h1>1017 Rate of Return 解题思路</h1>
<p>利润率越高，本金和利润之和越大，所以<span class="math">\(100 (1+x)^4 + 100 (1+x)^2\)</span>是一个单调函数，可以二分查找函数的零点</p>
</div><div id="rate-of-return-代码" class="slide section level2">
<h1>1017 Rate of Return 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> lo = <span class="dv">0</span>, hi = <span class="dv">1</span>;
<span class="kw">for</span> (<span class="dt">int</span> loop = <span class="dv">0</span>; loop &lt; <span class="dv">100</span>; ++loop) {
  <span class="dt">double</span> mid = (lo + hi) / <span class="dv">2</span>;
  <span class="dt">double</span> sum = <span class="dv">0</span>;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
    sum += amount[i] * pow(<span class="dv">1</span> + mid, month[n] - month[i] + <span class="dv">1</span>);
  }
  <span class="kw">if</span> (sum &lt; amount[n]) {
    lo = mid;  <span class="co">// 提高下界</span>
  } <span class="kw">else</span> {
    hi = mid;  <span class="co">// 缩小上界</span>
  }
}</code></pre>
</div>
<div id="exocenter-of-a-triangle" class="titleslide slide section level1"><h1>1059 Exocenter of a Triangle</h1></div><div id="exocenter-of-a-triangle-题目大意" class="slide section level2">
<h1>1059 Exocenter of a Triangle 题目大意</h1>
<div class="figure">
<img src="1059.png" />
</div>
<p>已知A，B，C，求O</p>
</div><div id="exocenter-of-a-triangle-向量的旋转" class="slide section level2">
<h1>1059 Exocenter of a Triangle 向量的旋转</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp">* exp(Point(<span class="dv">0</span>, pi / <span class="dv">2</span>))</code></pre>
</div><div id="exocenter-of-a-triangle-两点确定直线" class="slide section level2">
<h1>1059 Exocenter of a Triangle 两点确定直线</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> PointPointToLine(Point p1, Point p2, <span class="dt">double</span> *a, <span class="dt">double</span> *b, <span class="dt">double</span> *c) {
  <span class="co">// a x + b y + c = 0</span>
  <span class="co">// a (x1 - x2) + b (y1 - y2) = 0</span>
  *a = imag(p1 - p2);
  *b = -real(p1 - p2);
  <span class="co">// (y1 - y2) x1 - (x1 - x2) y1 + c = 0</span>
  <span class="co">// -x1 y2 + x2 y1 + c = 0</span>
  <span class="co">// c = x1 y2 - x2 y1 叉乘</span>
  *c = imag(conj(p1) * p2);
}</code></pre>
</div><div id="exocenter-of-a-triangle-两直线求交点" class="slide section level2">
<h1>1059 Exocenter of a Triangle 两直线求交点</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp">Point intersect(Point p1, Point p2, Point p3, Point p4) {
  <span class="dt">double</span> a1, b1, c1;
  <span class="dt">double</span> a2, b2, c2;
  PointPointToLine(p1, p2, &amp;a1, &amp;b1, &amp;c1);
  PointPointToLine(p3, p4, &amp;a2, &amp;b2, &amp;c2);

  <span class="dt">double</span> x = imag(conj(Point(b1, c1)) * Point(b2, c2));
  <span class="dt">double</span> y = imag(conj(Point(c1, a1)) * Point(c2, a2));
  <span class="dt">double</span> d = imag(conj(Point(a1, b1)) * Point(a2, b2));
  <span class="kw">return</span> Point(x / d, y / d);
}</code></pre>
</div><div id="exocenter-of-a-triangle-主过程" class="slide section level2">
<h1>1059 Exocenter of a Triangle 主过程</h1>
<div class="figure">
<img src="1059.png" />
</div>
<pre class="sourceCode cpp"><code class="sourceCode cpp">Point d = a + (b - a) * exp(Point(<span class="dv">0</span>, M_PI / <span class="dv">2</span>));  <span class="co">// #include &lt;cmath&gt;</span>
Point g = a + (c - a) * exp(Point(<span class="dv">0</span>, -M_PI / <span class="dv">2</span>));
Point l = (d + g) / Point(<span class="dv">2</span>, <span class="dv">0</span>);

Point e = d + b - a;
Point j = b + (c - b) * exp(Point(<span class="dv">0</span>, M_PI / <span class="dv">2</span>));
Point m = (e + j) / Point(<span class="dv">2</span>, <span class="dv">0</span>);

Point o = intersect(a, l, b, m);
<span class="kw">if</span> (abs(o.real()) &lt; <span class="fl">1e-6</span>) o.real() = <span class="dv">0</span>;
<span class="kw">if</span> (abs(o.imag()) &lt; <span class="fl">1e-6</span>) o.imag() = <span class="dv">0</span>;</code></pre>
</div>
<div id="hit-or-miss" class="titleslide slide section level1"><h1>1003 Hit or Miss</h1></div><div id="hit-or-miss-题目大意" class="slide section level2">
<h1>1003 Hit or Miss 题目大意</h1>
<p>n个人，第一个人开始时以一定顺序拿着标有1到13各4张的卡片堆</p>
<p>每个人分别执行以下两个步骤：</p>
<ol class="incremental" style="list-style-type: decimal">
<li>如果手上有卡，每次轮到自己则数一个数，从1开始，在1~13内循环，如果数的数刚好和自己的卡片堆最顶的卡片一样，则丢弃这张卡片，否则把这张卡片放到卡片堆底</li>
<li>除了第1个人，如果每个人前面的一个人有卡片丢弃，则把丢弃的卡片放到自己卡片堆底</li>
</ol>
<p>如此循环，直到每个人手上都没有卡片，或不能终止</p>
<p>如果可以结束，则输出每个人最后丢弃的卡片</p>
</div><div id="hit-or-miss-解题思路" class="slide section level2">
<h1>1003 Hit or Miss 解题思路</h1>
<p>认真阅读题意，按照题意直接模拟</p>
<p>当循环次数超过最大卡片张数（52）仍没有人抛弃卡片，则判断不能终止</p>
</div><div id="hit-or-miss-代码" class="slide section level2">
<h1>1003 Hit or Miss 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> player {
  queue&lt;<span class="dt">int</span>&gt; cards;
  <span class="dt">int</span> lastcard, count;
  <span class="dt">int</span> step1() {
    <span class="dt">int</span> discard = -<span class="dv">1</span>;
    <span class="kw">if</span> (!(cards.empty())) {
      <span class="dt">int</span> curr = cards.front();
      cards.pop();
      <span class="kw">if</span> (curr == count) {
        lastcard = discard = cur;
      } <span class="kw">else</span> {
        cards.push(cur);
      }
      <span class="kw">if</span> (count == <span class="dv">13</span>) {
        count = <span class="dv">1</span>;
      } <span class="kw">else</span> {
        ++count;
      }
    }
    <span class="kw">return</span> discard;
  }
};</code></pre>
</div><div id="hit-or-miss-代码-1" class="slide section level2">
<h1>1003 Hit or Miss 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> run() {
  <span class="dt">int</span> lastround = <span class="dv">0</span>;
  <span class="kw">for</span> (<span class="dt">int</span> round = <span class="dv">1</span>; round - lastround &lt;= <span class="dv">52</span>; ++round) {
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
      discards[i] = person[i].step1();
      <span class="kw">if</span> (discards[i] != -<span class="dv">1</span>) {
        lastround=round;
      }
    }
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; n; i++) {
      <span class="kw">if</span> (discards[i - <span class="dv">1</span>] != -<span class="dv">1</span>) {
        person[i].cards.push(discards[i - <span class="dv">1</span>]);
      }
    }
  }
}</code></pre>
</div>
<div id="a-card-trick" class="titleslide slide section level1"><h1>1018 A Card Trick</h1></div><div id="a-card-trick-题目大意" class="slide section level2">
<h1>1018 A Card Trick 题目大意</h1>
<p>一个魔术，助手把五张扑克的其中四张按一定顺序给魔术师，魔术师可能通过一定的规则计算出剩余的一张扑克</p>
<p>给出五张扑克，求出一个前四张牌的顺序，使得魔术师可以猜出第五张牌</p>
<ol class="incremental" style="list-style-type: decimal">
<li>Remember the suit and value of the first card.</li>
<li>Among the remaining three cards find the position of the smallest card (in the above order). Add this position (1, 2, or 3) to the value of the first card.</li>
<li>If the larger two of the last three cards are not in order, add 3 to the result of step 2.</li>
<li>The missing card has the same suit as the first card and value that computed in step 3 wrapping around if necessary.</li>
</ol>
<p>QH, 10D, 10C, 4D</p>
<p>Smallest of the last 3 cards is 4D in place 3</p>
<p>10D and 10C are out of order so add 3 + 3 to Q</p>
<p>Q + 3 + 3 = 5 =&gt; 5H</p>
</div><div id="a-card-trick-解题思路" class="slide section level2">
<h1>1018 A Card Trick 解题思路</h1>
<p>枚举五张扑克的顺序，找出其中合法的</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> check() {
  <span class="co">// 假设card[0]是要猜测的card</span>
  <span class="kw">if</span> (cards[<span class="dv">0</span>].suit != cards[<span class="dv">1</span>].suit) {  <span class="co">// rule 4</span>
    <span class="kw">return</span> <span class="kw">false</span>;
  }
  <span class="dt">int</span> result = <span class="dv">0</span>, min_pos = <span class="dv">2</span>, max_pos = <span class="dv">2</span>;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">3</span>; i &lt; <span class="dv">5</span>; ++i) {
    <span class="kw">if</span> (cards[i] &lt; cards[min_pos]) min_pos = i;
    <span class="kw">if</span> (cards[i] &gt; cards[max_pos]) max_pos = i;
  }
  <span class="dt">int</span> middle = <span class="dv">2</span> ^ <span class="dv">3</span> ^ <span class="dv">4</span> ^ min_pos ^ max_pos;
  result += min_pos - <span class="dv">1</span>;  <span class="co">// rule 2</span>
  <span class="kw">if</span> (middle &gt; max_pos) {  <span class="co">// rule 3</span>
    result += <span class="dv">3</span>;
  }
  <span class="kw">return</span> cards[<span class="dv">0</span>].num % <span class="dv">13</span> == (cards[<span class="dv">1</span>].num + result) % <span class="dv">13</span>;
}</code></pre>
</div><div id="a-card-trick-解题思路-1" class="slide section level2">
<h1>1018 A Card Trick 解题思路</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Card {
  <span class="dt">int</span> num;
  <span class="dt">char</span> suit;
};

<span class="dt">bool</span> <span class="kw">operator</span>&lt; (<span class="dt">const</span> Card&amp; a, <span class="dt">const</span> Card&amp; b) {
  <span class="kw">if</span> (a.num != b.num) {
    <span class="kw">return</span> a.num &lt; b.num;
  }
  <span class="kw">return</span> a.suit &lt; b.suit;
}</code></pre>
<pre class="sourceCode cpp"><code class="sourceCode cpp">sort(cards, cards + <span class="dv">5</span>);
<span class="kw">do</span> {
  <span class="kw">if</span> (check()) <span class="kw">break</span>;
} next_permutation(cards, cards + <span class="dv">5</span>);</code></pre>
</div>
<div id="candy-sharing-game" class="titleslide slide section level1"><h1>1052 Candy Sharing Game</h1></div><div id="candy-sharing-game-题目大意" class="slide section level2">
<h1>1052 Candy Sharing Game 题目大意</h1>
<p>M个学生围成一圈，开始时所有学生都有偶数的糖</p>
<p>每个回合，所有学生同时把手里的一半糖传给右边的学生</p>
<p>如果某个学生的糖数为奇数，则老师多给他一个糖</p>
<p>所有学生的糖数目相等时游戏结束</p>
<p>求回合数和每个学生手里的糖数</p>
</div><div id="candy-sharing-game-解题思路" class="slide section level2">
<h1>1052 Candy Sharing Game 解题思路</h1>
<p>游戏一定会结束，因为 1. 最大值不会变小 2. 最小值不会变大 3. 其他人都不会变成最小值 4. 至少一个最小值在一个回合后会变大</p>
</div><div id="candy-sharing-game-代码" class="slide section level2">
<h1>1052 Candy Sharing Game 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span> (<span class="dt">int</span> round = <span class="dv">0</span>; !allsame(); ++round) {
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
    tmp[i] = amount[i] = amount[i] / <span class="dv">2</span>;
  }
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
    amount[(i + <span class="dv">1</span>) % n] += tmp[i];
    amount[(i + <span class="dv">1</span>) % n] += amount[(i + <span class="dv">1</span>) % n] % <span class="dv">2</span>;
  }
}</code></pre>
</div>
<div id="pushing-boxes" class="titleslide slide section level1"><h1>1041 Pushing Boxes</h1></div><div id="pushing-boxes-题目大意" class="slide section level2">
<h1>1041 Pushing Boxes 题目大意</h1>
<p>一个矩形房间里面有若干箱子</p>
<p>每次操作是把房间的其中一面墙往里移动，把箱子推到新的位置，问最后所有箱子的位置</p>
</div><div id="pushing-boxes-解题思路" class="slide section level2">
<h1>1041 Pushing Boxes 解题思路</h1>
<div class="incremental">
<p>思路1：</p>
<p>分上下左右四种情况分别考虑</p>
<p>按照题目描述模拟</p>
</div>
<div class="incremental">
<p>思路2：</p>
<p>只考虑一个方向</p>
<p>当执行其他方向的操作时，先把房间旋转至默认方向，移动完毕后，再转回原来的方向</p>
</div>
</div><div id="pushing-boxes-解题思路-1" class="slide section level2">
<h1>1041 Pushing Boxes 解题思路</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// -----&gt; y</span>
<span class="co">// |</span>
<span class="co">// |</span>
<span class="co">// v</span>
<span class="co">// x</span>
<span class="co">// 先按x分类，再按y从大到小处理</span>
<span class="dt">bool</span> Cmp(<span class="dt">const</span> Point&amp; a, <span class="dt">const</span> Point&amp; b) {
  <span class="kw">if</span> (a.x != b.x) <span class="kw">return</span> a.x &lt; b.x;
  <span class="kw">return</span> a.y &lt; b.y;
}

<span class="dt">void</span> MoveRight(<span class="dt">int</span> m) {
  sort(box, box + n, Cmp);
  <span class="dt">int</span> x = -<span class="dv">1</span>, y;
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
    <span class="kw">if</span> (box[i].x != x) {
      x = box[i].x;
      y = m;
    } <span class="kw">else</span> {
      y++;
    }
    <span class="kw">if</span> (box[i].y &lt; y) {
      box[i].y = y;
    }
  }
}</code></pre>
</div>
<div id="商人的宣传" class="titleslide slide section level1"><h1>1211 商人的宣传</h1></div><div id="商人的宣传-题目大意" class="slide section level2">
<h1>1211 商人的宣传 题目大意</h1>
<p>有n个州，m条单向边，天数为L</p>
<p>q个询问，问从州A到州B刚好为L步的方案数</p>
</div><div id="商人的宣传-解题思路" class="slide section level2">
<h1>1211 商人的宣传 解题思路</h1>
<p>第0天，每个州到自己的方案数为1</p>
<p>第n+1天，每个州A到另一个州B的方案数为：</p>
<p>对所有州C，第n天从A到C的方案数与一天内从C到B的方案数的积，再对所有州求和（即第n天通过州C作为中转的方案数）</p>
</div><div id="商人的宣传-代码" class="slide section level2">
<h1>1211 商人的宣传 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> Solve(<span class="dt">int</span> A, <span class="dt">int</span> B) {
  memset(num_ways, <span class="dv">0</span>, <span class="kw">sizeof</span>(num_ways));
  num_ways[<span class="dv">0</span>][A][A] = <span class="dv">1</span>;
  <span class="kw">for</span> (<span class="dt">int</span> k = <span class="dv">1</span>; k &lt;= L; ++k) {
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
      <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; ++j) {
        num_ways[k][A][i] += num_ways[k - <span class="dv">1</span>][A][j] * edge[j][i];
      }
    }
  }
  <span class="kw">return</span> num_ways[L][A][B];
}</code></pre>
</div>
<div id="floors" class="titleslide slide section level1"><h1>1071 Floors</h1></div><div id="floors-题目大意" class="slide section level2">
<h1>1071 Floors 题目大意</h1>
<p>一块长方形地板是由很多长方形瓷砖组成的</p>
<p>每次可以将地板按水平方向或按竖直方向切割成两块，不能切到瓷砖，一直切，直到不能操作为止</p>
<p>问此时最大的块的面积</p>
<div class="figure">
<img src="1071.png" />
</div>
<p>分别可以切成9块，0块和6块</p>
</div><div id="floors-解题思路" class="slide section level2">
<h1>1071 Floors 解题思路</h1>
<div class="incremental">
<p>对于每一块，尝试平行于长方形的两边分别切割</p>
<p>对于分出来的小块，递归进行重复操作</p>
</div>
<div class="incremental">
<p>切割的方法：按垂直于切割线的方向对瓷砖进行排序，则切割相当于把一个数组从某个位置分割成两半</p>
</div>
</div><div id="floors-代码" class="slide section level2">
<h1>1071 Floors 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> Solve(<span class="dt">int</span> x1, <span class="dt">int</span> y1, <span class="dt">int</span> x2, <span class="dt">int</span> y2, <span class="dt">int</span> l, <span class="dt">int</span> r) {
  <span class="co">// [l, r], inclusive</span>
  <span class="dt">int</span> curr = (x2 - x1) * (y2 - y1);
  <span class="kw">if</span> (curr &lt;= ans) <span class="kw">return</span>;  <span class="co">// prune</span>
  ans = max(ans, curr);
  <span class="kw">if</span> (cutx(x1, y1, x2, y2, l, r)) <span class="kw">return</span>;
  <span class="kw">if</span> (cuty(x1, y1, x2, y2, l, r)) <span class="kw">return</span>;
}</code></pre>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> CompareX(<span class="dt">const</span> Rect&amp; a, <span class="dt">const</span> Rect&amp; b) {
  <span class="kw">return</span> a.x1 &lt; b.x1;
}

<span class="dt">bool</span> CutX(<span class="dt">int</span> x1, <span class="dt">int</span> y1, <span class="dt">int</span> x2, <span class="dt">int</span> y2, <span class="dt">int</span> l, <span class="dt">int</span> r) {
  sort(rects + l, rects + r + <span class="dv">1</span>, CcompareX);
  <span class="dt">int</span> mid_x = x1, area = <span class="dv">0</span>;
  <span class="kw">for</span> (<span class="dt">int</span> i = l; i &lt; r; ++i) {  <span class="co">// 注意不是i &lt;= r</span>
    area += rects[i].area;
    mid_x = max(mid_x, rects[i].x2);
    <span class="kw">if</span> (area == (mid_x - x1) * (y2 - y1)) {
      Solve(x1, y1, mid_x, y2, l, i);
      Solve(mid_x, y1, x2, y2, i + <span class="dv">1</span>, r);
      <span class="kw">return</span> <span class="kw">true</span>;
    }
  }
  <span class="kw">return</span> <span class="kw">false</span>;
}</code></pre>
</div>
<div id="manager" class="titleslide slide section level1"><h1>1082 MANAGER</h1></div><div id="manager-题目大意" class="slide section level2">
<h1>1082 MANAGER 题目大意</h1>
<p>现在有一个进程序列，每个进程都有消耗</p>
<table>
<thead>
<tr class="header">
<th align="left">有以下几</th>
<th align="left">种操作：</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">a x</td>
<td align="left">在序列中放进消耗为x的进程</td>
</tr>
<tr class="even">
<td align="left">r</td>
<td align="left">在序列中移除一个进程，根据策略可能是消耗最小或最大的</td>
</tr>
<tr class="odd">
<td align="left">p i</td>
<td align="left">设定策略</td>
</tr>
</tbody>
</table>
<p>给出一些输出序号，当执行的移除操作的次数和序号一致时，输出这次移除的进程的消耗</p>
</div><div id="manager-题目大意-1" class="slide section level2">
<h1>1082 MANAGER 题目大意</h1>
<p>建立二叉查找树，可以动态进行插入，删除，查找最大/最小值</p>
<p>可以使用stl里的map</p>
<p>记录每次移除的进程消耗，查询时直接输出</p>
</div><div id="manager-代码" class="slide section level2">
<h1>1082 MANAGER 代码</h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> append(<span class="dt">int</span> x) {
  process_map[x]++;
}

<span class="dt">int</span> remove() {
  <span class="kw">if</span> (p == <span class="dv">1</span>){
    it = process_map.begin();
  } <span class="kw">else</span> {
    it = process_map.rbegin();
  }
  <span class="dt">int</span> x = it-&gt;first;
  <span class="kw">if</span> (--it-&gt;second == <span class="dv">0</span>) {
    process_map.erase(x);
  }
  record[cnt++] = x;
  <span class="kw">return</span> x;
}</code></pre>
</div>
</body>
</html>
