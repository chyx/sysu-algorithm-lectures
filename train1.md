% 周练1（9月28日，3小时）
% chyx111@qq.com

# URAL 1001

* 题意：求整数($\le 10^{18}$)的开方

* 解法：用double的sqrt函数即可，精度是足够的。

* 注意：数据是反向输出的，有很多组数据。

. . .

double的读入应该使用：

~~~{.cpp}
scanf("%lf", ...)
~~~

而不是

~~~{.cpp}
scanf("%f", ...)
~~~


# URAL 1005 Stone Pile

* 题意：有最多20个石子，请分成两堆，使得两堆石子的重量差最小

* 石子重量不超过$10^5$

. . .

[划分问题](http://en.wikipedia.org/wiki/Partition_problem)是NP完全问题，
一般用暴力或者动态规划的方法解决

# URAL 1005 Stone Pile    解法1

$2^n$枚举第一堆中的石子

用一个0 ~ $2^n - 1$的二进制数来表示选择哪些石子

~~~{.cpp}
for (int msk = 0; msk < (1 << n); ++msk) {
  int sum1 = 0, sum2 = 0;
  for (int i = 0; i < n; ++i) {
    if (msk & (1 << i)) {
      sum1 += weight[i];
    } else {
      sum2 += weight[i];
    }
  }
}
~~~

. . .

复杂度$O(n 2^n)$

# URAL 1005 Stone Pile    解法2

用0/1背包算法来解

复杂度$O(nW)$，W是总重量的最大值

# URAL 1005 Stone Pile    解法3

拆半枚举，先把石子分成两堆，每一堆进行$2^{n/2}$的枚举

这两堆的枚举可以分别得到两个差值的集合，设为$D_1$, $D_2$

那么，最后差值为$d = d_1 + d_2, d_1 \in D_1, d_2 \in D_2$

可以给$D_1$，$D_2$分别排序，然后用移动指针的方法枚举得到最小值

. . .

复杂度$O(2^{n/2}n)$

# URAL 1014   Product of Digits

求一个最小的数字Q，满足它的每一位数字的乘积等于N

如：10对应的数字为25，因为2 $\times$ 5 = 10


# URAL 1014   Product of Digits   解法

对0和1做特殊处理：

. . .

0 -> 10, 1 -> 1

. . .

对一般情况：

N的因子必须只由2,3,5,7组成

其中，5和7的处理比较简单，我们知道这些数字必然直接出现在Q的十进制表示中

2和3比较复杂，它们的出现可能是由于2,3,4,6,8,9等数字导致的

但是，注意到我们的目标是让生成的数字尽量的少，而3个2可以组成8，2个3可以组成9，2和3可以组成6

所以，我们只需要从9到1，贪心地把数字配出来即可

最后需要将数字排序输出，因为我们需要的是最小的Q


# URAL 1020 Rope


