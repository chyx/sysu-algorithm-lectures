<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="chyx111@qq.com" />
  <title>周练2（10月12日，3小时）</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">MathJax.Hub.Queue(["Typeset",MathJax.Hub]);</script>
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">周练2（10月12日，3小时）</h1>
  <p class="author">
chyx111@qq.com
  </p>
</div>
<div id="uva-101-the-blocks-problem-题意" class="slide section level1">
<h1><a href="#uva-101-the-blocks-problem-题意">UVA 101 The Blocks Problem 题意</a></h1>
<div class="incremental">
<p>有N个位置，编号为0～N-1</p>
<p>初始时，各个位置上放置这和位置编号相同的砖块，即砖块1，砖块2，...，砖块N-1</p>
<p>五种命令操作方式：</p>
<ol class="incremental" style="list-style-type: decimal">
<li>move a onto b：把砖a移动到砖b上面，如果a和b上面都有砖块，要先把它们放回原来位置</li>
<li>move a over b：把a移动到有b的“砖堆”上面，移动前需要把a上面的砖块都恢复到原位置，b的堆保持不变</li>
<li>pile a onto b：把a之上的（包括a）搬到b之上，要先把b上面的砖放回到原来位置</li>
<li>pile a over b：直接把a之上的（包括a）搬到b所在的“砖堆”上</li>
<li>quit：结束命令</li>
</ol>
</div>
<div class="incremental">
<table>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"></td>
<td align="center">3</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">0</td>
<td align="left">1</td>
<td align="center">2</td>
<td align="left">_</td>
<td align="left">4</td>
<td align="left">5</td>
</tr>
</tbody>
</table>
<p><span class="math">\(n \le 25\)</span></p>
</div>
</div>
<div id="uva-101-the-blocks-problem-解法" class="slide section level1">
<h1><a href="#uva-101-the-blocks-problem-解法">UVA 101 The Blocks Problem 解法</a></h1>
<p>理解题意</p>
<p>直接用栈模拟</p>
</div>
<div id="uva-102-ecological-bin-packing" class="slide section level1">
<h1><a href="#uva-102-ecological-bin-packing">UVA 102 Ecological Bin Packing</a></h1>
<p>有Brown，Green，Clear三种颜色的杯子</p>
<p>现在有三个盒子，每个盒子中有三种数量不等的杯子</p>
<p>要使每个箱子中只有一种颜色的杯子，求需要移动最小的杯子数目以及之后每个箱中杯子的组成</p>
</div>
<div id="uva-102-ecological-bin-packing-解法" class="slide section level1">
<h1><a href="#uva-102-ecological-bin-packing-解法">UVA 102 Ecological Bin Packing 解法</a></h1>
<p>枚举三个盒子所有可能的最终状态</p>
<pre><code>BCG
BGC
CBG
CGB
GBC
GCB</code></pre>
<p>统计每种状态所需要的步数</p>
</div>
<div id="uva-103-stacking-boxes" class="slide section level1">
<h1><a href="#uva-103-stacking-boxes">UVA 103 Stacking Boxes</a></h1>
<p>给出几个多维的箱子</p>
<p>如果箱子的每一边都小于另一个箱子的对应边，就称这个箱子小于另一个箱子</p>
<p>求箱子套箱子最多能套多少层</p>
</div>
<div id="uva-103-stacking-boxes-解法" class="slide section level1">
<h1><a href="#uva-103-stacking-boxes-解法">UVA 103 Stacking Boxes 解法</a></h1>
<p>动态规划</p>
<p>dp[i], <span class="math">\(1 \le i \le n\)</span></p>
<p>dp[i] = 1 + max{dp[j], box j is inside box i}</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> dp[kMaxN];
<span class="dt">int</span> from[kMaxN];

<span class="kw">or</span>

pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; dp[kMaxN];</code></pre>
</div>
<div id="uva-104-arbitrage" class="slide section level1">
<h1><a href="#uva-104-arbitrage">UVA 104 Arbitrage</a></h1>
<p>n种货币</p>
<p>给出n行数据，每行n - 1个数字，表示该种货币与其他n - 1种货币的汇率</p>
<p>现在要在这些货币中找到一种货币，交换最少的次数，使得金额的数量增加（汇率大于1.01），并输出方案</p>
</div>
<div id="uva-104-arbitrage-解题思路" class="slide section level1">
<h1><a href="#uva-104-arbitrage-解题思路">UVA 104 Arbitrage 解题思路</a></h1>
<p>转化问题，找最短路，使得距离超过1</p>
<p>多解的情况找经过节点最多的路径</p>
</div>
<div id="uva-104-arbitrage-解题思路-1" class="slide section level1">
<h1><a href="#uva-104-arbitrage-解题思路-1">UVA 104 Arbitrage 解题思路</a></h1>
<p>Floyd算法求最短路</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; n; ++k) {
  <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
    <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; ++j) {
      dp[i][j] = dp[i][k] + dp[k][j];
    }
  }
}</code></pre>
</div>
<div id="uva-104-arbitrage-伪代码" class="slide section level1">
<h1><a href="#uva-104-arbitrage-伪代码">UVA 104 Arbitrage 伪代码</a></h1>
<pre class="sourceCode cpp"><code class="sourceCode cpp">best[i][j][s] = <span class="dv">0</span>, <span class="kw">for</span> all i,j,s
best[i][j][<span class="dv">1</span>] = input <span class="kw">for</span> the program
best[i][i][<span class="dv">1</span>] = <span class="dv">1</span>, <span class="kw">for</span> all i
path[i][j][<span class="dv">1</span>] = i, <span class="kw">for</span> all i, j

<span class="kw">for</span> (<span class="dt">int</span> steps = <span class="dv">2</span>; steps &lt;= n; steps++) {
  <span class="kw">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; n; ++k) {
    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
      <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; n; ++j) {
        tmp = best[i][k][steps<span class="dv">-1</span>] * best[k][j][<span class="dv">1</span>];
        <span class="kw">if</span> (tmp &gt; best[i][j][steps]) {
          best[i][j][steps] = tmp;
          path[i][j][steps] = k;
        }
      }
    }
  }
}</code></pre>
<p><span class="math">\(O(n^4)\)</span></p>
</div>
<div id="uva-105-the-skyline-problem" class="slide section level1">
<h1><a href="#uva-105-the-skyline-problem">UVA 105 The Skyline Problem</a></h1>
<p>给定数轴上若干条线段的端点，和这些线段上放置的矩形的高度</p>
<p>求矩形合并后的形状</p>
<div class="figure">
<img src="uva105.jpg" />
</div>
<p>坐标大小 &lt; 10000</p>
</div>
<div id="uva-105-the-skyline-problem-解法" class="slide section level1">
<h1><a href="#uva-105-the-skyline-problem-解法">UVA 105 The Skyline Problem 解法</a></h1>
<p>暴力记录每个位置上面的最高位置</p>
</div>
<div id="uva-114-simulation-wizardry" class="slide section level1">
<h1><a href="#uva-114-simulation-wizardry">UVA 114 Simulation Wizardry</a></h1>
<div class="incremental">
<p>模拟弹珠台</p>
<p>模拟题，认真读题，实现每一个细节</p>
</div>
<div class="incremental">
<p>小球碰到障碍物（墙或弹板）时仅会转向（顺时针转向）而不会移动，但无论小球是否移动生命值都要减1，因为每1步都消耗了1个单位的时间，碰到障碍物所减少的生命值另计</p>
<p>小球在移入弹板位置（下一步将被弹回到原位置）前生命值必须为正，否则不能得到分值，因为在移入的这个过程中小球的生命结束了</p>
<p>小球不能停留在任何障碍物的位置上，一旦发生碰撞必须立即回到原位</p>
<p>假设桌面的尺寸为3×3，桌面上就不可能有弹板，因为除了一圈子的墙外只有一格可供小球发射。在这种情况下，小球不会得到任何分值，生命值会在不断的撞墙中消耗殆尽</p>
</div>
</div>
<div id="uva-115-climbing-trees" class="slide section level1">
<h1><a href="#uva-115-climbing-trees">UVA 115 Climbing Trees</a></h1>
<div class="incremental">
<p>家谱树 确定两个人是否在一个家谱中存在亲属关系</p>
<p>给定一系列的“子-父”姓名对作为家谱，每对姓名中前者为子，后者为父</p>
<p>给定一系列的待查姓名对，表示两个人的姓名</p>
<p>需要判断对中的两个姓名是否在家谱中是否存在亲属关系</p>
</div>
<div class="incremental">
<p>亲属关系有4种：</p>
<ol class="incremental" style="list-style-type: decimal">
<li>子关系 包括孙、曾孙、玄孙等</li>
<li>父关系 包括祖父、曾祖父、高祖父等</li>
<li>cousin -- 0<sup>th</sup> cousin, 1<sup>st</sup> cousin, 2<sup>nd</sup> cousin, etc. p和q是cousins当且仅当它们在家谱树中是相连的， 假设p和q的公共祖先是r，它们距离公共祖先的距离分别是n和m，那么p和q是k代cousins，k = min(n, m)</li>
<li>兄弟 即0代cousins</li>
</ol>
<p>总人数 <span class="math">\(\le 300\)</span></p>
</div>
</div>
<div id="uva-115-climbing-trees-解法" class="slide section level1">
<h1><a href="#uva-115-climbing-trees-解法">UVA 115 Climbing Trees 解法</a></h1>
<p>查询树中两个节点的最小公共祖先 LCA</p>
<p>做法：</p>
<ul class="incremental">
<li>暴力 <span class="math">\(O(n^2)\)</span></li>
<li>Tarjan算法 并查集复杂度</li>
<li>转化为RMQ <span class="math">\(O(n \log n)\)</span></li>
<li>构造跳表 <span class="math">\(O(n \log n)\)</span></li>
</ul>
</div>
<div id="uva-117-the-postal-worker-rings-once" class="slide section level1">
<h1><a href="#uva-117-the-postal-worker-rings-once">UVA 117 The Postal Worker Rings Once</a></h1>
<div class="incremental">
<p>中国邮递员问题</p>
<p>邮递员从邮局出发送信，要求对辖区内每条街，都至少通过一次，再回邮局</p>
<p>最多存在两个奇数度的路口，其它所有路口的度均为偶数，即有偶数条街道与该路口相连</p>
</div>
<div class="incremental">
<p>连通的无向图<span class="math">\(G\)</span>有欧拉路径的充要条件是：<span class="math">\(G\)</span>中奇顶点（连接的边数量为奇数的顶点）的数目等于0或者2</p>
<p>有两个奇顶点？</p>
<p>用一条路径把两个奇顶点连接起来，用最短路算法求这条路径的长度</p>
</div>
</div>
<div id="uva-121-pipe-fitters" class="slide section level1">
<h1><a href="#uva-121-pipe-fitters">UVA 121 Pipe Fitters</a></h1>
<div class="incremental">
<div class="figure">
<img src="uva121.gif" />
</div>
<p>给出一个<span class="math">\(a \times b\)</span>的矩阵，问最多能放多少个圆柱体，叠放方式只有网格和交错方式两种</p>
</div>
<div class="incremental">
<p>解法：枚举</p>
<p><img src="uva121_1.PNG" /> <sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup></p>
<div class="figure">
<img src="uva121_2.bmp" />
</div>
</div>
</div>
<div id="uva-125-numbering-paths" class="slide section level1">
<h1><a href="#uva-125-numbering-paths">UVA 125 Numbering Paths</a></h1>
<div class="incremental">
<p>在一个所有街道都是单行线的城市中，询问两个点之间可行路径的数量</p>
</div>
<div class="incremental">
<p>解法</p>
<p>a-&gt;b的路径条数等于a-&gt;i与i-&gt;b的路径条数的乘积之和</p>
<p>用Floyd算法：</p>
<pre><code>for (k = 0; k &lt; n; k ++) {
  for (i = 0; i &lt; n; i ++) {
    for (j = 0; j &lt; n; j ++) {
      if (f[i][k] &amp;&amp; f[k][j]) {
        f[i][j] += f[i][k] * f[k][j];
      }
    }
  }
}</code></pre>
<p>正确性</p>
<p><span class="math">\(\circ^i \rightarrow [ \circ \rightarrow \circ \rightarrow .... \circ ]^{\lt k} \rightarrow \circ^j\)</span></p>
</div>
</div>
<div class="footnotes slide">
<hr />
<ol>
<li id="fn1"><p>http://www.cnblogs.com/devymex/archive/2010/08/15/1799966.html<a href="#fnref1">↩</a></p></li>
</ol>
</div>
</body>
</html>
